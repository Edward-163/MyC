lvm    logical volume manager将底层物理磁盘抽象封装,以逻辑卷呈现给上层,属于动态磁盘管理机制


层次结构
lv 举例如果xxxVG卷组里只有rootfs,bak-rootfs,log,那么vgdisplay输出中Cur Lv==3
vg 空间池
pv 把/dev/sda格式化成pv(专业术语条带化==把硬盘空间划成一个个的pe) 由pe组成,vg_size==pe大小*pe数量
  pe physicalExtent物理块  LVM 中最小的、可分配的存储单位,默认4M大小


必背5步
pvcreate /dev/sdb /dev/sdc
vgcreate vgNameXX /dev/sdb /dev/sdc
lvcreate -L 2G -n lvNameXX vgNameXX // 官网写法通常是lvName,vgName是最后两位
  延伸问题,如何查看vg中剩余多少G,vgs命令
  VG    #PV #LV #SN Attr   VSize   VFree
  hyjVG   1   3   0 wz--n- 445.59g 415.59g
mkfs.ext4 /dev/vgNameXX/lvNameXX
mount /dev/vgNameXX/lvNameXX /mnt


lvresize2 resize2fs2 
// -L 调整大小,
   -r --resizefs
   -f --force
lvresize -L+9G /dev/mapper/rootfs
lvresize -L-9M /dev/mapper/rootfs -rf // 就是修改大小后强制对fs更新,也就是省略下面的步骤
// lvm扩容缩容之后,df -h并没有变化,是因为文件系统创建完之后,文件系统size,type都是固定的,扩容缩容之后还需要对fs更新
resize2fs /dev/mapper/rootfs


lvremove /dev/vgNameXX/lvNameXX // 严格顺序要求,全删lv才能删vg,全删vg才能删pv
vgremove vgNameXX
pvremove /dev/sdb


lvm.conf  filter
// This is a list of regular expressions used to accept or reject block device path names
   LVM就只会扫描并管理/dev/sda和/dev/sdb这两个设备，其他设备会被过滤掉
filter = [ "a|^/dev/sda$|", "a|^/dev/sdb$|" ]
// Reject the cdrom drive:
filter = [ "r|/dev/cdrom|" ]
// vgchange代表改变vg属性 -a代表active -y代表yes                                      在系统中激活所有已知的卷组
   系统启动时，bios会扫描所有盘找到系统启动的引导文件。也就是boot分区(只有系统盘中才会有boot分区)，及分区内的grub.cfg，引导文件initrd等。引导入内存后根据lvm.conf2的过滤条件激活逻辑卷，然后挂载启动
lvm vgchange -ay 


fdisk -l
pvscan
pvs
pvdisplay
// -C 以多列方式输出
vgdisplay -C
VG    #PV #LV #SN(snapshots卷组快照数量)   Attr   VSize VFree
cpsVG   1  15   0                         wz--n- 1.45t 1.30t

vgscan
vgs

lvscan2 
ACTIVE '/dev/vg0/data' [1000.00 MB] inherit
ACTIVE '/dev/vg1/web' [20.00 GB] inherit
inactive '/dev/vg2/backup' [50.00 GB] inherit

lvdisplay2 
他的输出老多了,


vgchange2 
// -a avtive
   -y yes
vgchange -ay /dev/xxxVG/  # 激活单个卷组
vgchange -ay      # 激活系统中所有卷组




