union共用体:因为成员共用一块空间
https://blog.csdn.net/m0_57180439/article/details/120417270
由于共用空间这种特点就导致了，你改变c，i也会随之改变。这里和结构体是完全不一样的，结构体成员相互独立，但联合体不一样，改一个，其他的也会改变。
所以这里，在同一时间，你只能使用一个联合体成员，你使用c就不要用i，因为你c改变的时候，一定会影响到你i的使用，程序非常容易出问题。

long在32/64位都占4字节,指针占4/8字节

问:打不打印??
void test01(){
    int i=-1;
    for(;i<sizeof(int);i++){
        printf("%d \n",i);fflush(stdout);
    }
}
答:sizeof返回unsigned,而有符号-1转无符号??,在计算机补码看来,32位1拉满了都,没谁会比这个??大0xFF FF FF FF

char short int unsignedInt long
所有float都先转double运算
赋值运算,右边转成左边
char与short运算都转成int

c编译器 内置宏
__LINE__：在源代码中插入当前源代码行号；
__FILE__：在源文件中插入当前源文件名；(绝对路径)
__DATE__：在源文件中插入当前的编译日期 月日年
__TIME__：在源文件中插入当前编译时间； 时分秒
__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；

结构体对齐
注意:字节对齐和编译器有关,甚至可以设置2,4,8,16,如vs默认8字节对齐,但这个设置好像不起作用,有int还是按照4字节来??涉及实际对齐字节
    1、含有数组：数组就是多个基本类型变量，比如  char a[10],就是有a[0] 到  a[9]  共10个char类型变量；
    2、含有结构体：比较嵌套的结构体中最大与本结构体中最大，取大的那个；
    3、预编译指令#pragma pack(n)手动设置     n取1 2 4 8 16
    上面三者取最小的,就是实际对齐单位；
成员顺序排列,因为成员要按字节对齐,所以中间可能留有空白,顺序会影响结构体大小
short地址必须是2的倍数
int地址必须是4的倍数
double地址必须是8的倍数
终极大招:预定义#pragma pack(n) 来强制修改编译器字节对齐
记载于test03
https://blog.csdn.net/qq_40737025/article/details/106738762
结构体A应从offset为A内部最大成员的整数倍的地方开始存储
结构体嵌套有点绕!!

union对齐

inline函数