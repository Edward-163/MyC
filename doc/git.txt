git-am之前， 你要首先git am –abort 一次，来放弃掉以前的am信息，这样才可以进行一次全新的am。 Apply a series of patches from a mailbox
git-am 可以一次合并一个文件，或者一个目录下所有的patch，或者你的邮箱目录下的patch.
git-am ~/patch/0001-trival-patch.patch // 据说am会把多个提交信息合成一个? apply则不会提交,待验证

其他
.gitignore只能忽略未被track的文件，而git本地缓存。如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。
git rm --cached -r .
git add XXXdir // 只会add目录下面untrack文件
git commit -m 'update ignore'
git commit --amend // 追加方便,一般后接git push -f


git bisect start 终点commit 起点commit //
git bisect good/bad
git bisect reset // quit

// origin/通常固定写法,后面才是远程分支名
git checkout -b huawei/csi/euleros_virtual/v2r9/6.2.0  origin/huawei/csi/euleros_virtual/v2r9/6.2.0
git checkout -b newName origin/master

git cherry-pick 其他分支名 commmitId     // 从其他分支摘取一个commit,接到当前分支head后面
git cherry-pick 其他分支名 commitA^..commitB     // 从其他分支[commitA,commitB]摘过来,接到当前分支head后面

git clean XXXdir -n // -n dryRun
git clean XXXdir -f

git clone ??.git /home/??   // git clone 最后可以指定目录名
git clone ??.git D:\??

ubuntu上git默认的文本编辑器是nano，执行下面的命令将git的文本编辑器改为我们熟悉的vim
git config --global core.editor vim

git diff    // This form is to view the changes you made relative to the index 说白了查看 工作区-->还没暂存到index的改变-->index
git diff --staged   // 查看staged changes 等同--cached 说白了查看 工作区-->index(中的改变)
git diff commit1 commit2    // (1,2]
git diff > 0003.patch

// 前开后闭,注意中间有.. 注意中间有.. 注意中间有..
git format-patch e4d14012cf3436f8c7f7306aa0bbd113effc7728~1..e4d14012cf3436f8c7f7306aa0bbd113effc7728 // 0001-virtiofs-add-vhost_user_fs-package.patch
git format-patch 35b1ce814ca6fea6a1207b4b935c55b229f3b6c3 –stdout          //--stdout输出到console查看,实践测试,不写第二个commitId,默认是HEAD
git format-patch HEAD^       //生成(HEAD^,HEAD]之间的patch,也就是head指向的commitId的patch,一般来说也就是最近一次提交的patch
git format-patch HEAD^^     //生成(HEAD^^,HEAD]之间的patch ,一般来说也就是最近2次提交的patch
git format-patch HEAD -1 –stdout        //生成(HEAD^,HEAD]之间的patch,也就是head指向的commitId的patch,一般来说也就是最近一次提交的patch
等价
git format-patch HEAD^..HEAD  –stdout
git format-patch HEAD -2 –stdout        //生成(HEAD^^,HEAD]之间的patch ,一般来说也就是最近2次提交的patch
等价
git format-patch HEAD^^..HEAD  –stdout
git format-patch -1 commitId // 生成commitId单次提交文件

添加vhost_user_fs/src/lib.rs等文件中,git status只会显示未跟踪vhost_user_fs/   ,(从其它地方cp而来的文件不显示,天坑)
git ls-files --others --exclude-standard

git log --oneline
git log --pretty=oneline
    美[ˈprɪti] 英['prɪtɪ]
    adj.漂亮的；动听的；指不够真诚的褒奖；宜人的
    adv.相当；很
    n.心肝；衣饰
    网络可爱的；美丽的；俊俏的



git push --set-upstream origin <远程分支名>            // 注意: 中间是空格 中间是空格 中间是空格
-u=--set-upstream
把本地分支关联到远程主分支；为每个更新或推送的分支设置远程引用
若远程仓库没有<远程分支名>时，会自动创建该分支名

// 更新fork仓库<<官方仓库
// 自己远程改了12个补丁,但官方远程更新了许多,此时自己的pr会显示与官方远程冲突,
// 添加官方远程源
git remote add origin_o https链接或者ssh链接
// 抓取官方仓库所有分支的更新(无则新增,有则更新),缺点:可能新增大量的分支
git fetch origin_o
// 需要特定分支可以在origin_o后面加上
git fetch origin_o branchXXX
// 额外:抓取后fork的origin和官方的origin_o分支进度不一样,我想用官方全覆盖fork怎么办呢?

// 把自己12个补丁"追加"到自己的最新的远程,需要用到rebase,待补充rebase动图
// 多分支变基,找出当前分支和origin_o/dev分支的共同祖先节点,从此点开始提取当前分支的提交,并追加到origin_o/dev分支的末尾(有瑕疵,虽然上面fetch->多分支变基->解决冲突->rebase --continue->push -f 自己fork仓,可以完美解决问题,但这行文字表达有瑕疵!!!)
git rebase -i origin_o/dev

// 单分支变基,举例如下,变更最近两次"互不干扰"的提交的顺序
git rebase -i HEAD~2

git reset --mixed HEAD^ // 默认参数,保留修改,撤销本地提交和撤销git add    知识点:HEAD(指针) index(暂存区) workingTree==workDir(工作区)
git reset --sort HEAD^ // 保留修改,撤销本地提交,不撤销git add
git reset --hard HEAD^ // 修改无了,相当于回滚到上一个提交
git reset --hard origin/dev // 本地当前分支重置成和远程一样
https://vue3js.cn/interview/git/HEAD_tree_index.html#%E4%B8%80%E3%80%81head


本地推目录到github和gitee,每次都只能一个目录(但可以包含多个文件),想多个目录一起推,gitBash就卡死或者报错了
github生成的token可以直接在setting中添加,比gitBash在远程url中添加加token要更方便些.
早上到公司添加第二个token的时候提示Ed..账号已添加,token不让加了?!!
git remote set-url origin https://<your_token>@github.com/<username>/<repo>.git


github限制25M文件,太大gitBash推送会卡住,上传大文件[25M,100M]还要专门下载git lfs




// git pull 强制覆盖本地  -f 实操并未达到我想要的效果(远程代码直接覆盖本地),每次还得处理冲突,
// git fetch从远程下载最新的，而不尝试合并或rebase任何东西。
git fetch --all
// 然后git reset将主分支重置为您刚刚获取的内容。 --hard选项更改工作树中的所有文件以匹配origin/master中的文件。
git reset --hard origin/master

git reflog -9 // 通常错误操作会是HEAD@{0},所以通常回到错误的前一个记录上
git reset --mixed HEAD@{1}

可以直接按目录restore多个文件
git restore --staged patches/hulk_7.5/

git revert -n 此命令通过在版本库中创建一个“反向的”新提交来抵消原来提交的改动。通常Git会立即提交反转结果，但是也可以通过参数-n告诉Git先不要提交，
 这用于反转多个提交非常有用，运行多个git revert –n命令，Git会暂存所有的变更，然后做一次性提交。做反转操作的时候必须提供提交名称，
 反转总是按照从新到旧点的倒序来操作的，即最后的提交最先反转，这样可以避免一些不必要的冲突。

git show commitId --stat // 查看提交的文件列表

git stash save 'hyj'
git stash list
git stash apply stash@{编号,0是栈顶}
git stash drop stash@{编号,0是栈顶}
git stash pop                           // 不推荐,==apply栈顶+drop栈顶

