.gitignore只能忽略未被track的文件，而git本地缓存。如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。
git rm --cached -r .
git add .
git commmit -m 'update ignore'

git cherry-pick 其他分支名 commitA^..commitB     // 从其他分支[commitA,commitB]摘过来,接到当前分支head后面

git diff    // This form is to view the changes you made relative to the index 说白了查看 工作区-->还没暂存到index的改变-->index
git diff --staged   // 查看staged changes 等同--cached 说白了查看 工作区-->index(中的改变)
git diff commit1 commit2    // (1,2]
git diff > 0003.patch

// 前开后闭,注意中间有.. 注意中间有.. 注意中间有..
git format-patch e4d14012cf3436f8c7f7306aa0bbd113effc7728~1..e4d14012cf3436f8c7f7306aa0bbd113effc7728 // 0001-virtiofs-add-vhost_user_fs-package.patch
git format-patch 35b1ce814ca6fea6a1207b4b935c55b229f3b6c3 –stdout          //--stdout输出到console查看,实践测试,不写第二个commitId,默认是HEAD
git format-patch HEAD^       //生成(HEAD^,HEAD]之间的patch,也就是head指向的commitId的patch,一般来说也就是最近一次提交的patch
git format-patch HEAD^^     //生成(HEAD^^,HEAD]之间的patch ,一般来说也就是最近2次提交的patch
git format-patch HEAD -1 –stdout        //生成(HEAD^,HEAD]之间的patch,也就是head指向的commitId的patch,一般来说也就是最近一次提交的patch
等价
git format-patch HEAD^..HEAD  –stdout
git format-patch HEAD -2 –stdout        //生成(HEAD^^,HEAD]之间的patch ,一般来说也就是最近2次提交的patch
等价
git format-patch HEAD^^..HEAD  –stdout

// 自己远程改了12个补丁,但官方远程更新了许多,此时自己的pr会显示与官方远程冲突,
// 第一步,把自己的远程更新为官方远程
// 第二步,把自己12个补丁"追加"到自己的最新的远程,需要用到rebase,待补充rebase动图
git remote add origin_o https://gitee.com
git fetch origin_o
// 多分支变基,找出当前分支和origin_o/dev分支的共同祖先节点,从此点开始提取当前分支的提交,并追加到origin_o/dev分支的末尾
git rebase -i origin_o/dev

// 单分支变基,举例如下,变更最近两次"互不干扰"的提交的顺序
git rebase -i HEAD~2

git reset --mixed HEAD^ // 默认参数,保留修改,撤销本地提交和撤销git add    知识点:HEAD(指针) index(暂存区) workingTree==workDir(工作区)
git reset --sort HEAD^ // 保留修改,撤销本地提交,不撤销git add
git reset --hard HEAD^ // 修改无了,相当于回滚到上一个提交
https://vue3js.cn/interview/git/HEAD_tree_index.html#%E4%B8%80%E3%80%81head


本地推目录到github和gitee,每次都只能一个目录(但可以包含多个文件),想多个目录一起推,gitBash就卡死或者报错了
github生成的token可以直接在setting中添加,比gitBash在远程url中添加加token要更方便些.
早上到公司添加第二个token的时候提示Ed..账号已添加,token不让加了?!!
git remote set-url origin https://<your_token>@github.com/<username>/<repo>.git


github限制25M文件,太大gitBash推送会卡住,上传大文件[25M,100M]还要专门下载git lfs




// git pull 强制覆盖本地  -f 实操并未达到我想要的效果(远程代码直接覆盖本地),每次还得处理冲突,
// git fetch从远程下载最新的，而不尝试合并或rebase任何东西。
git fetch --all
// 然后git reset将主分支重置为您刚刚获取的内容。 --hard选项更改工作树中的所有文件以匹配origin/master中的文件。
git reset --hard origin/master



git stash save 'hyj'
git stash list
git stash apply stash@{编号,0是栈顶}
git stash drop stash@{编号,0是栈顶}
git stash pop                           // 不推荐,==apply栈顶+drop栈顶

