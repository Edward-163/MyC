我在每个命令后面加个2只是方便搜索
bios自检            检查硬件是否正常
bootloader引导程序  grub就是其中之一
grub加载vmlinuz(被压缩的内核文件)            bootloader加载内核(/boot/vmlinuz-5.10.0XXX.x86_64包含内核启动代码和必要的驱动)到内存中,内核解压自己并启动
   解压vmlinuz到随意目录,你就能看到 init -> usr/lib/systemd/systemd
内核解压initramfs(临时根文件系统)         /boot/initramfs-5.10.0XXX.x86_64.img,包含linux系统所需驱动和必要文件到内存中(举例 帮内核加载硬件驱动)，并执行其中的 /init 脚本
   执行init进程           第一个进程(举例systemd),读取/etc/inittab配置,启动其他进程
      后续会运行dracut-cmdline等dracut子命令
      lsinitrd initramfs-5.10.0-136.12.0.86.h1428.aarch64.img |grep dracut-cmdline
切根               init完成初始化工作后,内核卸载initrd临时系统,切根到你平时常见/下面(无论是大伟博客还是宏涛给的journal.log都是先启动systemd,很后面才切根swicthRoot)
   在新的根文件系统上执行真正的初始化进程（如 /sbin/init，现在通常是 systemd），其进程号（PID）为1。此后，systemd将负责启动所有剩余的系统服务


第一内核 主内核
第二内核 主内核crash时候启用,cmdline中crashkernel=256M 就是预留给第二内核使用的


配置串口
// x86
console=tty0 console=ttyS0,115200
// arm
console=tty0 console=ttyAMA0,115200


解压iso 解压解包
#!/bin/bash
isoname=$1
mkdir m
# iso镜像文件,系统自动采用 loop设备来挂载它,而 loop设备恰好是一种将文件虚拟成块设备的机制,加不加-o loop效果一样
mount $isoname m
# minios里面没有repo目录,常规iso里面有
cp m/repo/OS.tar.gz ./
# 解压后就一个initrd文件,一个linux可执行文件
tar xf OS.tar.gz
mkdir in
mv initrd in
cd in
# -c --stdout      write on standard output, keep original files unchanged,gunzip将解压后的内容输出到标准输出（屏幕），而不是写入一个解压后的文件。这是使用管道的关键。
# 需要（gunzip和 cpio）接力完成，是因为 initrd文件本身是一个“压缩包中的打包文件”，需要先解压，再解包
gunzip -c initrd | cpio -id
cd ..
umount m
rm -rf m OS.tar.gz linux


重置root密码2 
按e进入grub页面
启动参数删掉console=tty0 XXX;(奇怪,删掉串口输出为啥)添加rd.break=mount         
mount -o remount,rw /sysroot
chroot /sysroot
passwd -d root // 下面是备选方法?
   vim /etc/shadow 把root:XX: 前两个冒号之间的密码密文删掉,:wq   
   echo "root:XXX" |chpasswd
passwd root 
sync // 用于 强制将内存缓冲区中的数据写入磁盘
ctrlD ctrlD 正常进大系统
涛哥:小系统密码a==iso安装时密码a,进大系统后passwd改密码b,小系统密码a不变
另一种办法:systemd.debug-shell=1,ctrlAltF9切入单用户模式passwd修改密码,ctrlAltF1切出用新密码登录


完整的ip==网络地址+主机地址+子网掩码
2^6=64,网段最大值255.255.255.255     256=2^8
127.0.0.1/8       255.0.0.0(掩码)   所有(二进制)前8位相同的IP地址都属于这个网段(或者说属于同一个子网,可以直接通信),实际覆盖了 127.0.0.0 ~ 127.255.255.255
192.168.1.0/24	   255.255.255.0	   192.168.1.0 ~ 192.168.1.255	实际覆盖了256个ip


rd.break2  
我试过了rd.break不写默认效果是mount,草ds乱说的
我试过了rd.break不写默认效果是mount,草ds乱说的
// /sysroot下面空的
rd.break=pre-mount
// 可以认为/dev/mapper/rootfs已经挂载到/sysroot,它下面有内容
rd.break=mount
// 逻辑卷不识别的时候,/dev/mapper/只剩个control,其他卷设备是空的                激活逻辑卷->挂卷->切根
rd.break=initqueue


systemd.debug-shell=1  
tty9 终端（默认 CtrlAltF9）开启一个 root 权限的 Shell，即使系统服务崩溃或无法登录
有一次
kernel panic - not syncing: Attempted to kill init  东哥说systemd坏了,让我修,修复ctrlD一路往下multipathd.service又报错了
rd.break=mount systemd.debug-shell=1 console=tty0 -> 走到multipathd.service报错 -> ctrlAltF9 -> systemctl status multipathd -> /sbin/multipathd二进制提示少了.so


bc2 
// -l mathlib
   scale=2000 保留小数点后2000位
   4*a(1)==圆周率,pi=180度,tan(45度)=1,arctan(1)=45度,4*arctan(1)=180度=pi
time echo "scale=2000;4*a(1)" |bc -l  // 用于简易测试环境cpu性能??


blkid2 
// 查询系统块设备的文件系统类型   以sda为例,常见叫法 磁盘设备 或者 分区
blkid /dev/sda
/dev/sda1 的本质：
   它只是块设备的标识符（类似于书的封面条形码），不代表文件内容本身。
   直接操作 /dev/sda1 相当于操作原始磁盘扇区，需要专业工具（如 dd 或 debugfs）。
挂载的作用：
   将设备中的文件系统映射到目录树（如 /mnt），操作系统才能理解文件结构。
   类比：必须把书翻开（挂载）才能阅读或修改内容，只看条形码（/dev/sda1）无法编辑。


blktrace2 
// -d dev
   报错FAILED to start thread on CPU 0: 22/Invalid argument,因为当前进程被加到cpuset的cgroup子系统里面了，被限制了只能访问部分cpu
   解决:echo $$ >> /sys/fs/cgroup/cpuset/cgroup.procs 
blktrace -d /dev/sda3  
// -i inputFile
   -d dump-binaryFile
blkparse -i sda3 -d sda3dump.bin
btt -i sda3dump.bin > sda3.log // 蔡俊杰:正常来说就应该d2c高,正常需要看blktrace的avg(毫秒)和max
            ALL           MIN           AVG           MAX           N
--------------- ------------- ------------- ------------- -----------

Q2Q               0.000001500   0.244555772   4.985332850         386
Q2G               0.000000730   0.000047734   0.006542980         156
G2I               0.000004060   0.000036119   0.000097100         118
Q2M               0.000000400   0.000000867   0.000003550         231
I2D               0.000003380   0.000019430   0.000041450         120
M2D               0.000011820   0.000029214   0.000087970         228
D2C               0.000190170   0.002012626   0.007984870         386
Q2C               0.000348400   0.002078108   0.007998110         387


capability2 
https://www.cnblogs.com/sparkdev/p/11417781.html
从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 capabilites。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：
在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有 capability CAP_KILL；如果设置系统时间，
就得具有 capability CAP_SYS_TIME。


capsh2 
// --caps 设置进程能力集
   --keep 用户切换后保留能力集(默认切用户丢弃)
   --user 指定用户
   --addamb 添加XX能力到ambient能力集
   -- -c pythonXX 丢弃所有输出 错误也转成输出(此处也会丢弃)
capsh --caps="cap_dac_override,cap_setgid,cap_setuid,cap_setpcap+ip" --keep=1 --user="cps" --addamb="cap_dac_override" -- -c "python /usr/bin/logrotate.py >/dev/null 2>&1"


cat2 
// 什么都不写就是,你屏幕输入什么,打印什么
cat
// 当前屏幕在线写脚本,ctrl D 退出书写,这么玩不如vim,因为当前屏幕在线写没有退格,只能ctrl U,ctrl W 啥的来删除
cat > test.sh


chage2 
chage -l root // list account info
Last password change					: Nov 10, 2023
Password expires					: Feb 08, 2024
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 90
Number of days of warning before password expires	: 7


chmod2 
// -R 目录以及文件递归改
chmod 777 -R /sys/fs/cgroup/cpu/hyjXX


chown2 
chown root:root b.txt // 改变文件的所有者:所有者组
chown root a.txt //
chown :root c.txt //


chrt2 
诉求:把进程杀掉再拉起,要求0.5s以内,这时候这块知识就有用了
实时进程与普通进程区别在于schedule策略
实时进程 SCHED_FF先进先出 SCHED_RR轮训
普通进程 SCHED_OTHER                      cls列显示为TS
ps -eo pid,comm,cls,rtprio -p pid
// -f 设置SCHED_FF先进先出
   -r 设置SCHED_RR轮训
chrt -p pid
chrt -f 99 // 优先级[1,99最高]
chrt -r 99


cgroup2 
进制占用内存不受限制,oom
进制占用cpu不受限制,其他进程无法得到调度,执行超时or失败,这就是为啥引入cgroup的原因
memory.usage_in_bytes 当前已用内存(曾经有一次echo 3 > /proc/sys/vm/drop_caches后,某cgroup的该值与top中某进程的res值接近)
// 已知pid,查看cgroup相关,如:查看memory的限制,它一般位于输出的第二行 memory:/system.slice/XXX/XXX/XXX
   需要拼接 /sys/fs/cgroup/memory/system.slice/XX
   需要拼接 /sys/fs/cgroup/memory/system.slice/XX
cat /proc/XXX/cgroup 


cpio2 
把文件/目录归档到XXX.cpio中或者从XXX.cpio中提取出来
// -o create archive 代表归档或者创建
   archive - Bing dictionary   US[ˈɑrˌkaɪv]UK[ˈɑː(r)kaɪv]
   n.档案；档案馆；档案室
   v.把…存档；把…归档；将（不常用信息）存档
ll /home/ | cpio -o > a.cpio
// -i --extract  Extract files from an archive,[ˈɑːrkaɪv] n 档案;档案馆;档案室;档案文件;
   -d 代表必要时自动创建目录,但我自己试过创建X.cpio并提取,似乎对源目录没啥子影响,也没什么打印,所以一时半会看不出cpio的意义是啥
cpio -id a.cpio
// 提取rpm包中文件,-v代表verbose
rpm2cpio X.rpm | cpio -idv


cpuinfo2 
// -c 指定cpulist
cpuinfo -c 0-3 freqency-info
performance性能模式就是没调频
coresmart根据负载智能切换高性能/节能模式   coresmart就是调频
每个核单独可以，但是用通配命令去改就报错
echo coresmart | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
tee2 把输入输出到文件中并保存(实测,源文件内容被删除覆盖)


cracklib2 弱密码 密码字典
// 解析字典,并输出字典规则内容到文件中,当 pw_dict 不存在时，cracklib-unpacker 可能自动尝试加载其他关联文件（如 pw_dict.pwd），因此不会直接报错
cracklib-unpacker /usr/share/cracklib/pw_dict > /home/a.txt
create-cracklib-dict a.txt  // 生成新的二进制字典
update-cracklib  // 更新字典索引
echo "123" | cracklib-check // 密码预检查


curl2 
curl is a tool for transferring data from or to a server using URLs
// -i 在输出中包含 HTTP 响应头（便于调试）
   -g 允许url可以包含{}[]
   -k --insecure不安全,大概就是跳过验证步骤
   -X GET	明确指定 HTTP 方法为 GET（默认即为 GET，可省略
   -H "accept: application/json"要求返回json格式
curl -igk -X GET https://XXX -H "accept: application/json"


date2 
date [option]..[+format]
// 什么是format,举例 %Y 四位年份 %m 月份 %d 日
date +%m_%d // 输出举例 01_17
   #!/bin/bash
   month_day=$(date +%m%d)
   status="status_${month_day}"
   smaps="smaps_${month_day}"
   #echo ${status}
   cat /proc/1/status > /home/${status}
   cat /proc/1/smaps > /home/${smaps}

// 根据str set时间,主机时间莫名其妙被改了,可以手动改回来
date -s "2024-04-17 10:18:50"
// display time described by STRING, not 'now',官方举例如下,1970至今秒数
date -d'@2147483647'
date --date='@2147483647'


/dev/null2 
/dev/zero2 
// linux 2个特殊的文件 
/dev/null  ： 在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。
/dev/zero  ： 在类UNIX 操作系统中, /dev/zero 是一个特殊的文件，当你读它的时候，它会提供无限的空字符(NULL, ASCII NUL, 0x00)。


dd2 
// /dev/zero  /dev/null 在上面
dd if=/dev/zero of=/mnt/test bs=1M count=10 oflag=direct
if      input file
of      output file
ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。
obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。
bs=bytes：同时设置读入/输出的块大小为bytes个字节。
iflag=direct 绕开fs的缓存
oflag=direct


df2 
df -h // disk free
df -i // 列出分区inode使用情况,inode被用光了也可能报错no space left
df -T // 打印fs类型


dhclient2 
一般来说就是出网卡发包到pxe服务器上dhcpServer,获取ip,获取不到,最便捷的是先去dhcpServer抓包分析
// -v verbose log ,动态获取ip,并显示详细过程,
   -x shutDown client
dhclient -v
dhclient -v eth4 // 附:可以指定网络接口
dhclient -x


dmesg2 
// -C 清除环回缓冲区
// -c 打印当前的缓冲区内容并清除,有次巡检不同过,就是把它备份后-c清空,难道巡检与dmesg有什么强相关?
dmesg -c


dmidecode2 
// -t 指定类型  0-bios 1-system 等等
dmidecode -t bios
dmidecode -t 1
dmidecode -t processor // 如展示core一共多少个,启用多个少core


dos2unix2 
将Windows格式文件转换为Unix、Linux格式的实用命令
// 比如你将window上sh脚本拷贝至linux环境,就容易提示\r错误异常
dos2unix XX.sh


dracut2
将为当前运行的内核版本生成一个新的initramfs映像文件，并将其保存在/boot目录下
// 不加force会提示不会覆盖已有镜像,加了后,镜像的modify,change会更新,
dracut --force
// 举例
1 /etc/lvm/lvm.conf,放开filter = XXX行 
2 dracut --forece命令重新打包
3 解压镜像(/usr/lib/dracut/skipcpio initramfs-5.10.0-182.0.0.95.h2545.eulerosv2r13.aarch64.img |zcat |cpio -id)再查看变化       解压镜像命令,前两段有点难懂


du2 
du -hs // diskUsage,默认显示当前目录,-s 总结      显示当前目录总大小
du -hs * // 显示当前目录,每个子项的大小


e2fsck2 
// check a Linux ext2/ext3/ext4 file system


echo2  默认末尾加换行
// echo --help是看不到帮助的,需要找出echo位置,如/usr/bin/echo --help       
// -n 表示不要换行输出,-e解析反斜杠
echo -n "末尾不自动加换行,本str会直接输出在右侧"


/etc/pam.d/     Pluggable Authentication Modules  
举例bmc界面登录,输完账号不能输入密码,直接login incorrect,无奈的办法就是对比异常/正常的/etc/pam.d内文件,有差异就替换吧
// 比如sshd内容第一行
auth       substack(将另一个pam配置文件作为子栈嵌入当前配置)     password-auth(这就是另一个pam配置文件)
auth       sufficient(足够的,此行auth认证后,跳过后续auth认证)    pam_unix.so nullok try_first_pass


/etc/fstab2 
磁盘被手动挂载之后都必须把挂载信息写入/etc/fstab这个文件中，否则下次开机启动时仍然需要重新挂载。 系统开机时会主动读取/etc/fstab这个文件中的内容，
根据文件里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了
fs_freq参数决定了文件系统是否需要进行备份。具体来说，如果这个参数设置为0，表示该文件系统不需要执行dump操作，即不需要进行备份；如果设置为其他值，则表示该文件系统需要定期执行dump备份。
fs_passno参数则用于指定系统重启时文件系统的检查顺序。通常，fs_passno为1的文件系统会在其他文件系统之前被检查，这通常是指root文件系统；而fs_passno为2的文件系统会在所有fs_passno为1的文件系统之后进行检查。
   fsck程序会按照fs_passno的顺序来检测磁盘，即先检查fs_passno为1的文件系统，然后是fs_passno为2的文件系统，以此类推。0值的fs_passno意味着该文件系统不被fsck检查。
/dev/cpsVG/rootfs / ext4 acl,dioread_lock,data_err=abort,nospeed,defaults,iversion 1 1
/dev/md2 /boot ext4 defaults,iversion,nodev,dioread_lock,data_err=abort,nospeed 1 2


/etc/profile2 
全局配置文件,用户登录时会自动执行它


/etc/profile.d/ 
包含系统级别脚本,用户登录时被执行


个人配置文件      ~/.bashrc           敲alias展示结果来源于此
`~/.bashrc` 是 Bash shell 的配置文件，它包含了一些用户自定义的环境变量、别名、函数和命令等。当用户登录到一个 Bash shell 时，Bash 会自动执行 `~/.bashrc` 文件中的命令，
以设置用户的环境变量和自定义命令等。这个文件通常用于设置用户的个性化环境，比如设置命令别名、添加 PATH 环境变量、定义 shell 函数等。
rc 代表run command,类似的还有~/.vimrc 我喜欢默认加上:set nu hls cursorline cursorcolumn
注意             改完记得source file // source命令 "从file中读取并执行命令"


&&  第一个命令退出码0才执行第二个命令,以此类推
确认I层内存总体使用量，命令：cd /sys/fs/cgroup/memory/system.slice/fsp && cat memory.usage_in_bytes && cat memory.limit_in_bytes


/etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin // 7列
logName:密码全部用X代替:uid:gid:userName:homeDir:用户登陆后默认的shell程序
真实密码在/etc/shadow中,加密串,不是明文,好像也没啥卵用
/sbin/nologin 或者 /bin/false 代表禁止此用户默认登录

/etc/sysconfig/network-scripts/ifcfg-eth0 // 默认网卡配置文件 <linux系统命令及shell脚本实践指南> 6章 网络管理
如果网口不在这个目录里面,说明网口不受network管理,由上层业务下发管理


ethtool2 eth2 
// -i interface 显示网络接口eth0的驱动信息,网络接口与网卡的物理网口(插孔)是两码事
   -P permanent Addr ,也称 hardware Addr,也称 MAC
ethtool -i eth0
ethtool -P eth0 



// export命令声明了将由子进程所继承的一个或多个变量。这些变量被导出后，当前shell脚本所执行的任何应用程序都会获得这个变量。
// 在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。
linux配置path,全用户有效,举例:配置rust的path
vim /etc/profile
export PATH="$PATH:~/.cargo/bin"
export -p //列出当前的环境变量值
source /etc/profile


faillock2 
// 重置用户登录失败次数
faillock --user=root --reset


fdisk2 
manipulate disk partition table
fdisk /dev/sda
   n 新建一个新分区
   p (新建主分区)
   1 (使用第1个主分区)
   两次回车(使用默认配置)
   wq (保存分区表)
// -l List the partition tables for the specified devices and then exit.
fdisk -l /opt/disk.img 
mount -o loop,offset=1048576 /opt/disk.img /mnt // 想访问镜像中的某个分区，而不想整个挂载。因为直接mount loop会挂载整个镜像，但镜像里可能有多个分区，他们需要指定具体分区的起始位置
mount -o loop,offset=34603008 /opt/disk.img /mnt
Device           Boot Start     End Sectors  Size Id Type
/opt/disk.img1        2048  999423  997376  487M 83 Linux
/opt/disk.img2      999424 8388607 7389184  3.5G 8e Linux LVM
从上面可知第一个分区的 Start是 2048。偏移量 = 2048 * 512= 1048576


find2 
// -type d 只查找目录 
   2>/dev/null 标准错误流向"无底洞",也就是丢弃错误信息
find / -name uvp-getosstat -type d 2>/dev/null  
// find 会直接打印当前目录所有,下面更简短更强
find |grep log
find . -name log*
// -xdev 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件,举例,假设/目录是ext4,u盘文件系统是iso9660,从/搜索rpm就搜不到u盘里的rpm
find / -xdev -name \*.rpm
// %p 代表fileName(注意英文的file==中文文件+目录),假设/home下面有个dir0,里面只有个a.txt,那么下面输出两行,一行是/home/dir0,一行是/home/dir0/a.txt
find /home/dir0 -printf '%p\n'
// %h 代表dirname且去掉了末尾的fileName(linux manual,理解了%p就能理解这个),下面命令分两行完成!!!大致意思:遍历/home下每个文件,但是呢,只打印目录+换行           "哪个目录inode占用多"
   每个文件或者目录都会占用一个inode条目
find /home -printf '%h\n' | uniq -c |sort -k 1 -n
// -type f 搜索regularFile   
   %s 文件bytes大小
   %p 代表fileName(注意英文的file==中文文件+目录)
   -n numeric(按数字大小默认升序) 
   -k 1 指定第一列排序                                  "最大文件",find命令无法搜索到lsof中deleted大文件,find机制:遍历目录树举例/,检查每个目录项dentry,而deleted文件没有dentry,补充dentry知识点?
find /var/log -type f -printf '%s %p\n' |sort -n -k 1


free2 
free -m


fuser2      
Show which processes use the named files, sockets, or filesystems.
// -m show all processes using the named filesystems or block device
   -v verbose
fuser -mv /var/log


fsck2 
通常修分区4步
// umount第一条,不能在当前目录结构当前目录
umount mountPoint
// -n 以只读模式运行`fsck`，即不对文件系统进行任何实际的修复操作 
   -f 表示强制运行`fsck`，即使文件系统被标记为“干净”（clean），也会进行检查和修复
      skipped journal recovery because doing a read-only check指的是 fsck​​工具自身运行的模式​​。-n选项告诉 fsck​​仅仅检查文件系统，但拒绝进行任何实际的修复,并不是指分区只读
fsck -nf /dev/sda 
fsck -y /dev/sda
mount /dev/sda mountPoint
场景:-y之后-nf还是提示log分区有损坏,
解决:log如果不需要的保留的话,走格式化,挂镜像,mkfs /dev/VG/log


grep2 
背景 大概找一下下面这个宏是哪些补丁用到了,假设有(对比开源版本的商用的版本的补丁),看是不是漏打补丁了
#ifndef OPENSSL_FIPS         // ndef==not defined 这个宏没有定义
# error FIPS is disabled.
#endif
// -r递归目录(grep最后可以接单个文件,多个文件,或者目录配合-r) -n显示行号 -w单词匹配 -v反转查找
   当前目录下有很多补丁,从补丁从查找谁用到openssl_fips这个宏,并且把ifdef给排除掉,最后一个grep仅仅是为了颜色高亮,因为第二个grep -v会把高亮抹掉
   r 递归目录 
   n行号 
   w单词匹配  
   E拓展表达式 v取反
   -A3     // 多展示后面3行
   -B3     // 多展示前面3行
   -C3     // 多展示后面前后各3行
grep -rnw OPENSSL_FIPS ./ | grep -v ifdef | grep OPENSSL_FIPS        
// -m 最大匹配行数
ps -aux |grep -m 2 'root'
ps -ef |grep -E 'warn|err|critical'


grub2 手动引导2 
grub.cfg位置x86在grub/ ;arm在efi/??
无故进入grub模式,屏幕显示grub>
// hd0,1,2 gpt1,2,3    如果你发现下面展示和正常的节点/boot内容相同
ls (hd1,gpt2)/
// 手动引导
set root=hd1,gtp2
linux /vmlinuz-XX root=/dev/cpsVG/rootfs console=tty0
initrd /initramfs-XX.img
boot
grub2-mkconfig -o /boot/efi/EFI/euleros/grub.cfg，重新生成grub.cfg文件。生成成功后reboot，OS恢复正常


hwlock2 
// rtc硬件时钟==hwlock -r       systemtime==date  
// -r display rtc
// -w 虽然w不是write的意思,通常叫法是"写硬件时钟"   用什么写呢,当然是systemtime    set rtc from system time
// -s 反过来  set system time from rtc
hwclock -w


ifconfig2 
// -a 展示所有network interface,不加只展示激活的interface
ifconfig -a
ifconfig eth0 up


ima2 
/etc/ima/ima-policy
Integrity Measurement Architecture，完整性度量架构）是内置于Linux内核的安全子系统，它像一个尽职的​​系统安全审计员和守卫​​，核心目标是确保系统内关键文件（如可执行程序、库文件、内核模块等）的​​完整性
场景:权限755,file命令提示no read permission
根因:有一行本应该是measure变成了appraise评估(它比较严格,所以拒绝访问文件了)
cat << EOF >> /etc/ima/ima-policy
#appraise func=MMAP_CHECK mask=MAY_EXEC obj_type=XXXvirtual_exec_t
measure func=MMAP_CHECK mask=MAY_EXEC obj_type=XXXvirtual_exec_t
有一次文件chmod755,但是file文件提示no read permission,涛哥说可能与标签相关,后来发现涉及到这块,selinux,cmdline开启ima
measure 是被动记录文件的完整性哈希，用于审计和证明。
appraise评估 是主动强制检查文件的完整性，如果不通过则拒绝访问。


iostat2 
// -d 显示disk统计信息,默认disk和avg-cpu都会显示,所以这  -d -c没卵用,不如不加
   -c display cpu utilization实际展示avg-cpu
   -m 单位 MB
   -k 单位 KB
   -t     Print the time for each report displayed 每小段统计数据上方有一行时间戳
   -x display extended statistics
iostat -mtx 1 5 /dev/sda /dev/sdb // 1 每隔1s刷新一次    5 共刷新5次
iostat -mtx 1 // 每1秒刷新一次,一直刷
字段:
rrqm/s：   每秒有多少个"取件请求"被你合并处理了（比如把同一栋楼的5个取件合并成1趟）,通俗讲就是有没有小io合并成大io
   想象一下，一个应用程序需要读取磁盘上连续的几个数据块（例如，块 100, 101, 102, 103）。
   没有合并：I/O 调度器可能会收到4个独立的请求：
   READ from block 100
   READ from block 101
   READ from block 102
   READ from block 103
   这会导致向硬盘发送4次命令，带来4次寻道和延迟开销（即使它们彼此相邻）。
   有合并：聪明的 I/O 调度器会发现这些请求是访问连续的磁盘区域。于是，它会将这4个小请求合并成1个大的请求：
   READ from block 100, length 4 blocks
   这样，只需要向硬盘发送1次命令，硬盘执行一次连续读取就能完成所有任务，效率大大提高。
wrqm/s：   每秒有多少个"寄件请求"被你合并处理了（比如把寄往同一城市的3个包裹合并成1个包裹）
rKB/s    读带宽
avgrq-sz   和/sys/block/sdb/queue/max_sector_kb有关联        https://bean-li.github.io/dive-into-iostat/
avgqu-sz   待处理io队列大小,平均值,值越大,"排队的人越多"


ip a 
ip是个很强的命令,有很多子命令如 ip addr      ip link      ip route 等
ip a show eth0
10: eth0: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1800 qdisc mq master trunk2 state UP group default qlen 1000
    link/ether a4:6d:a4:90:3d:5e brd ff:ff:ff:ff:ff:ff  // 该接口的MAC地址
    inet6 fe80::d84d:36ff:fec4:936/64 scope link        // ipv6
       valid_lft forever preferred_lft forever
10          编号10,从1开始没啥好说的
UP          表明eth0被启动,逻辑上 // 例如有次pxe报错dhclient enpXXX failure,ip a show显示这个enpXXX网卡呢没有up,lower_up,只能通过ethtool查看这个网卡的2层链路状态
LOWER_UP    表明eth0物理链路上已连接
mtu==max trans unit最大传输单元   单位是字节
qlen 1000    接收队列的长度为1000
brd ff:ff:ff:ff:ff:ff   广播地址

ip a s // 感觉这两个命令用来查询网卡信息,没区别呀...


ip addr del
背景:eth0和bro0的mac是一样的,我dhclient -v之后,这个主机我就ssh连不上了
东哥:有了ip后,他就不是二层口,三层口,他不需要ip,总之说了一堆复杂的,建议删除ip命令
ip addr del 9.13.3.11/32 dev eth0
eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq master ovs-system state UP group default qlen 1000
    link/ether 14:30:04:ea:87:8a brd ff:ff:ff:ff:ff:ff
    inet6 fe80::1630:4ff:feea:878a/64 scope link
       valid_lft forever preferred_lft forever
br0: <BROADCAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000
    link/ether 14:30:04:ea:87:8a brd ff:ff:ff:ff:ff:ff
    inet 9.13.3.11/16 brd 9.13.255.255 scope global dynamic br0
       valid_lft 76115sec preferred_lft 76115sec
    inet6 2000:13::1630:4ff:feea:878a/64 scope global dynamic mngtmpaddr
       valid_lft 2591998sec preferred_lft 604798sec
    inet6 fe80::2088:76ff:fe20:8de4/64 scope link
       valid_lft forever preferred_lft forever


// 将物理网卡 eth5 的第 4 个虚拟网卡的带宽限制为 1000 Mbps
ip link set eth5 vf 4 rate 1000
ip link set eth4 down/up
// 网络接口前面加个dev似乎没缺点
ip link set dev eth6 vf 9 mac 00:11:22:33:44:55


// 展示所有网口信息  这个命令会显示vf配置在xml中的mac地址,ip a不行
ip link show |grep XXX 
ip link show eth9
up               L3网络层      管理员手动控制,独立于物理状态,如ifconfig up/down属于3层,ip link set eth0 up/down 同理
link detected:   L2数据链路层    由硬件/驱动直接检测
lower_up                        物理链路激活,网线已连接且交换机端口正常               等价于detected:yes
NO-CARRIED       L1物理层      物理链路断开，比如网线没插好之类的                  等价于detected:no


ipmitool2 
// mc特质主板上负责ipmi的基板管理控制器baseboard manager controller
ipmitool mc watdog get
// 对ipmi的网络接口(lan通道,特指bmc的专用管理网络接口),其ip address输出就是bmc的ip
ipmitool lan print


iptables2 ip6tables 
硬件->数据包->内核空间(netfilter框架)->用户空间(iptables,可以视作框架的接口)
iptables->包含表->包含chain->rule(从上往下执行rule行)
最最最常见的表是filter(包含input,output,forward链)             iptables --table filter --list 等同于iptables -L
// -v verbose
   -n numeric
   -L 列出[chain [rulenum]]
   --line-numbers   显示行号,删除rule的时候用得到行号
iptables -vnL

iptalbes --tables filter --append INPUT --source 172.28.XX  --jump DROP // 其实它的选项你不锁写的话,很好理解
// -D 删除chain [rulenum]   删除名为input的chain中第二条rule
iptables -D INPUT 2

// 保存在/etc/sysconfig/iptables中
service iptables save
// -A INPUT 给input规则append
   -p tcp 指定协议是tcp
   --dport   指定des端端口8002
   -s        指定src端地址
   -j        指定动作ACCEPT DROP REJECT 等    This specifies the target of the rule; i.e., what to do if the packet matches it.
ip6tables -A INPUT -p tcp --dport 8002 -s 2409:8080:5A0A:6058::/80 -j ACCEPT 
// 删除所有rule
   -F Flush the selected chain (all the chains in the table if none is given).  This is equivalent to deleting all the rules one by one.
iptables-save > /home/XX.txt
iptables -F
iptables-save < /home/XX.txt


irqbalance2 
/etc/sysconfig/irqbalance
IRQBALANCE_BANNED_CPUS=ffffffff,fffffffc,ffffffff,fffffffc
f 代表(先转成2进制,全是1)不参与中断   一位16进制==4位二进制,上面32位16进制==128位2进制,刚好当前环境上cpu是128核
0 代表参与中断
irqbalance意义:每个核上均匀参与中断处理,使性能更佳


iscsiadm2 
    iscsi target：存储设备端，服务器端的设备，为其他服务器提供“磁盘”。
    Iscsi initiator：使用target提供“磁盘”的客户端。
// 发现阵列ip==对端业务ip的目标,用于​​发现​​指定存储服务器（Target）上可供连接的存储资源,
   -m discovery 指定发现模式
   -t st：指定发现类型为 ​​sendtargets（可简写为 st）​​。这是最常用的方式，意思是让存储服务器把它提供的存储目标列表“发送”过来
iscsiadm -m discovery -t st -p ip:port // 像是​​你（客户端）根据地址（IP:Port）去询问仓库管理员（存储服务器）：“你们仓库里有哪些货架（Target）可以让我放货？”​​ 管理员会给你一份清单
// -l login
   -u logout
iscsiadm -m node -p XX.XX.XX.XX -l 
iscsiadm -m node -p XX.XX.XX.XX -u
// 查询当前主机登入的存储设备
iscsiadm -m session
// 查看当前主机上发现所有target
// -T targetName
iscsiadm -m node




jobs bg fg & ctrl+Z 后台
// 假设很耗时,ctrl+Z暂停此任务
tar -zcf usr.gz /usr 
// 展示任务,不出意外上述任务编号为1
jobs
// 后台运行任务1号,fg类似
bg 1
// 或者一开始指定后台运行 &
tar -zcf usr.gz /usr &


journalctl2 
一个用于查询和显示由systemd日志管理系统（systemd-journald服务）收集的日志信息的工具
// -u 参数指定了要查看的服务的名称，例如 `journalctl -u ssh
journalctl -u sshd	
// -f follow the journal 展示最新日志 journal杂志,日志  entry[n]记录,词条 journey[n v]旅游
   应用场景:cps host-list显示虚拟机fault,查看journalctl日志发现rootfs没挂上去?或者fsck失败?手动fsck
   挂iso启动,dmesg和journalctl只针对当前镜像启动,没什么参考价值
journalctl -f -u sshd 


killall2 
// -w Wait for all killed processes to die
// 实操加不加前置路径都可以
killall -w /sbin/dhclient


ldconfig2 
ldconfig 命令用于在默认搜寻目录 /lib 和 /usr/lib 以及动态库配置文件 /etc/ld.so.conf 内所列的目录下，搜索出可共享的动态链接库（格式如 lib*.so*），进而创建出动态链接器（ld.so 或 ld-linux.so）所需的缓存文件。
缓存文件默认为 /etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表。为了让动态链接库为系统所共享，需运行动态链接库的管理命令 ldconfig 更新动态链接库的缓存文件。
附
/proc/sys/vm/drop_caches 是一个系统文件，它允许用户在 Linux 操作系统中清除内核缓存。这个文件包含一个整数，它控制哪些缓存应该被清除。具体来说，这个整数的值可以是以下之一：
- 0：什么都不清除(默认)
- 1：清除页缓存。
- 2：清除目录项和inode缓存。  dentries and inodes   如何理解dentries??
- 3：同时清除页缓存、目录项和inode缓存。
---
echo 3>/proc/sys/vm/drop_caches
rm -f /etc/ld.so.cache
ldconfig
---


ldd2 
print shared object dependencies 列出某程序所需动态链接库(.so)
// 问题1:无法restart nscd,报错symbol lookup error
ldd /usr/sbin/nscd // 他的libc来源于glibc-XXoe版本,这不对,euler环境就应该不用oe的包

// 问题2:切根后panic,串口回忆如下               
   failed start kenel modules
   system-load.service??
   starting switch root
   kernel panic
   断点pre-mount
mount /dev/mapper/rootfs /sysroot
chroot /sysroot
ldd /usr/lib/systemd/systemd                                                                举例,输出提示/usr/lib/systemd/libsystemd-shared-XX.so=>not found
没有共享库文件->从正常环境拷贝一份
 有且md5sum变化   从正常环境拷贝
 有且md5sum不变   ldconfig刷新


ln2 
// ln -s target link_name


lo2 
ifconfig中的lo是虚拟网络接口,作用类似于给自己写纸条,不经过外界


loop2 
把文件模拟成块设备(硬盘就是常见的块设备)


losetup2 
// 将文件（如磁盘镜像）关联到 /dev/loopX 设备，使其可像物理磁盘一样操作
losetup /dev/loop0   /opt/XXX/image/instance/disk.eph0
// 如果这个镜像文件包含分区表的话,举例:就能看到/dev/mapper/loop0p1 /dev/mapper/loop0p2
kpartx -av /dev/loop0


ls2 
// -Z 仅在 SELinux 处于 ​​Enforcing（强制模式）​​ 或 ​​Permissive（宽容模式）​​ 时才有意义。如果 SELinux 被禁用（Disabled），所有文件的安全上下文通常显示为 system_u:object_r:unlabeled_t:s0或类似内容，表明它们未被标记
ls -Z XX.so


lsattr2  
lsattr /etc/passwd // 拓展属性
// -a appendOnly
   -i Immutable (不可变)	文件不能被修改、删除、重命名，不能创建指向它的链接，也不能写入数据。 最高级别的保护
chattr +i /etc/passwd


lsblk2
// -f 输出fs类型
lsblk -f
NAME                   MAJ:MIN  RM  SIZE RO TYPE MOUNTPOINT
sda                      8:0     0  3.5T  0 disk
├─sda1                   8:1     0  500M  0 part /boot/efi
├─sda2                   8:2     0  500M  0 part /boot
└─sda3                   8:3     0  3.5T  0 part
  ├─rootfs             253:0     0   11G  0 lvm  /
注意看/boot/efi  /boot  / 分别在sda123  -> 由 UEFI 规范、引导流程需求和分区管理最佳实践 共同决定的



lscpu2
有时候不同节点的cpu的flag不同,也有称为cpu feature的,而这些cpu flag从硬件获取的,大概率是bios设置相关,举例bios开关MonitorMwaitEnable,开了flag里面就有monitor这个值,没开就没有
sockets            主板上物理cpu插槽
cores per socket   单个cpu的物理核心数
threads per core   每个物理核心能同时处理的线程数                  逻辑cpu核数==socket*core*thread


lsof2
// list open file
// 如 df -h某分区占满,du -hs --max-depth=99 /home 下面没几个大文件or目录,就极有可能是进程占用句柄没有释放
lsof |grep delete |grep home
lsof -i:22 // -i 选项有点长 [46][proto][@host|addr][:svc_list|port_list] 
lsof -i:4TCP:22 // 查看ipv4,tcp协议,端口22相关的打开的文件
lsof -p 10086 // 查询指定进程打开的文件
lsof |grep 10080 // 这种是全量查询再过滤pid,输出可能包含tid=XXX或者为空的行,去掉tid为空的行的统计结果才是进程打开的文件行
// -t 仅输出pid,通常与kill配合使用,https://www.man7.org/linux/man-pages/man8/lsof.8.html
lsof -t /var/log 


lspci2 
lspci | grep Eth // 系统把网卡硬件识别成pci设备(rev 01正常识别,rev ff无法识别)，少了pci是系统问题
ll /sys/class/net // 这个是驱动把pci设备识别成网络接口，少了网络接口是驱动问题
ixgbe 0000:86:00.0 failed to load beacuse an unsupported SFP+ or QSFP module type was detected   什么意思?
在尝试加载英特尔ixgbe万兆网卡驱动时，检测到了不支持的SFP+或QSFP模块类型。这意味着网卡无法识别或支持当前插入的光模块

// -s 指定domain bus device func号
   -v verbose   
lspci -vvvs 0000:00:03.0
lspci -vvvs 00:03.0
// -t show bus tree 有次他问两套环境配置一样,但pci不同,直接正常/异常敲命令并对比,发现差异pci号了,网卡位置插得对不对?                    
   pci号是硬件决定的，系统这边只是取一下，不做分配
   设备增删都会触发bus 地址的重新分配，分配规则是：bus号从小到大顺序分配。如果把bus号小的设备拔掉，原型bus号大的会变小，拔掉bus号大的，不会影响bus号小的(bios的能力?)
lspci -tv 


scsi2 
SCSI（Small Computer System Interface），中文全称是“小型计算机系统接口”。你可以把它想象成一条​​高效且智能的“设备高速公路”​​，它能让多种设备（如硬盘、光驱、扫描仪等）以一种相对聪明和快速的方式与计算机连接和通信

lsscsi2 
// -g Output the SCSI generic device file name.
   -H lists scsi hosts rather than scsi devices​​不要显示具体的磁盘或设备，而是只显示这些设备所连接的“主机控制器”
lsscsi -g
   scsi设备地址  设备类型   厂商     型号              固件版本  块设备      scsi通用设备 
   [0:0:0:0]    disk      ATA      ST1000DM010-2EP1  CC43     /dev/sda   /dev/sg1
   [H:C:T:L]编号。这里的 H(Host) 就是指该设备连接在哪个主机控制器上
   块设备:直接存取数据,像餐厅点菜 块设备​​（Block Device）是一种以固定大小的数据块（如512字节或4KB）为单位进行读写的设备，例如硬盘驱动器（HDD）、固态驱动器（SSD）、U盘等。/dev/sda是系统中第一块SCSI或SATA类型磁盘的​​块设备文件
   scsi通用设备:发送底层scsi命令,像进厨房对厨师下特殊命令,例如sg_format /dev/sg0,功能强大但是危险
   /dev/sda是给文件系统和常规存储工具用的“标准接口”，而 /dev/sg1是给工程师和诊断工具用的“底层调试接口”
// ([0], [1]...)​​: 这是系统为每个SCSI主机控制器分配的唯一标识号, 主机控制器”或“主机适配器”是100%的物理实体​​。它就是插在您电脑或服务器主板上的​​一块物理芯片或一张扩展卡​​，是连接CPU和硬盘的桥梁。\
   ds主机控制器举例:集成控制器(主板芯片),扩展卡式控制器(pcie卡,raid卡归属于这种),虚拟控制器(cpu模拟)
lsscsi -H
[0]    megaraid_sas驱动
[1]    ahci​​驱动


io路径科普



lvcreate2 
// -L --size 指定大小
   -n --name 指定逻辑卷名字
   cpsVG  实际存在的某个卷组
lvcreate -L 10G -n upgrade cpsVG
mkfs.ext4 /dev/cpsVG/upgrade               // 格式化逻辑卷


lvm2 
lvm.conf  filter
// This is a list of regular expressions used to accept or reject block device path names
   LVM就只会扫描并管理/dev/sda和/dev/sdb这两个设备，其他设备会被过滤掉
filter = [ "a|^/dev/sda$|", "a|^/dev/sdb$|" ]
// Reject the cdrom drive:
filter = [ "r|/dev/cdrom|" ]
// vgchange代表改变vg属性 -a代表active -y代表yes                                      在系统中激活所有已知的卷组
   系统启动时，bios会扫描所有盘找到系统启动的引导文件。也就是boot分区(只有系统盘中才会有boot分区)，及分区内的grub.cfg，引导文件initrd等。引导入内存后根据lvm.conf2的过滤条件激活逻辑卷，然后挂载启动
lvm vgchange -ay 
lvm2 
lv      如果cpsvg卷组里只有rootfs,bak-rootfs,log,那么lv==3
vg
pv      由pe组成,vg_size==pe大小*pe数量
pp(盘
vgdisplay -C
VG    #PV #LV #SN(snapshots卷组快照数量)   Attr   VSize VFree
cpsVG   1  15   0                         wz--n- 1.45t 1.30t


lvresize2 resize2fs2 
// -L 调整大小,
lvresize2 -L+9G /dev/mapper/rootfs
lvresize2 -L-9M /dev/mapper/rootfs
resize2fs /dev/mapper/rootfs


md5sum2 
// 某目录下有多个文件,可以用*指定多个文件
md5sum *
//
md5sum XXX.txt


mkdir2 
mkdir -p /root/rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}  
花括号 {}用于​​生成字符串序列​​，可以自动展开为多个独立的字符串,上面一条命令==6条命令


mknod2 
// -m 指定权限 c 字符设备 13分别是主次设备号(为啥13不懂)
mknod -m 666 /dev/null c 1 3 


mkfs2 
// 在设备sda上创建文件系统==格式化分区
mkfs /dev/sda
// 在设备sdb上创建ext4类型文件系统
mkfs.ext4 /dev/sdb


modinfo2 modprobe2 
// 可以先查询下有没有ko,有的话再modprobe打上ko
   1. modprobe 命令会自动加载所需的依赖模块，而 insmod 命令则不会。如果一个模块依赖于其他模块，使用 modprobe 命令可以自动加载这些依赖模块，而使用 insmod 命令则需要手动加载这些依赖模块。
   2. modprobe 命令会从 /etc/modprobe.conf 和 /etc/modprobe.d 目录中读取配置文件，以确定要加载的模块及其参数。而 insmod 命令则需要手动指定要加载的模块及其参数。
modinfo ipmi_watchdog
modprobe ipmi_watchdog


mount2 
// -o loop 选项时，mount 命令会自动找到一个可用的回环设备（如 /dev/loop0）。这个回环设备会将 XXX.iso 文件虚拟化为一个块设备。当你使用 mount命令挂载一个 ​​.iso镜像文件​​ 时，系统自动采用 ​​loop设备​​来挂载它。这主要是因为ISO文件
本身是一个​​普通文件​​，而非物理块设备（如硬盘分区），而 loop设备恰好是一种​​将文件虚拟成块设备​​的机制
   -o 后面接逗号分割options,remount选项代表重新挂,rw选下来代表读写,例如原先只读的系统，现在以可读写的模式重新挂上
mount -o loop XX.iso /mnt/iso // 实测,加不加loop,我看.iso挂完后lsblk,type列都是loop 
mount -o remount,rw /dev/mapper/cpsVG-image // mount device|dir -o options  官网:写设备和写挂载点都可以
// -B --bind 把一个目录"镜像"到另一个位置，就像给文件夹创建了一个"分身"或"快捷方式+"。
   -R, --rbind             mount a subtree and all submounts somewhere else
mount --rbind /proc proc/



mpstat2
mpstat [-P {|ALL}] [internal [count]]
// -P {|ALL} 表示监控哪个CPU， cpu在[0,cpu个数-1]中取值
   internal 相邻的两次采样的间隔时间、
   count 采样的次数，count只能和delay一起使用
   监视cpu8,9,10,11的数据 间隔1秒 采样2次 输出3段内容,最后一段是前2段采样的平均值
mpstat -P 8,9,10,11 1 2 
mpstat -P 0-13 2 5
%irq 硬中断
%soft 软中断


multipath2 
// -f 您想要删除的特定多路径设备名
multipath -f 多路径盘uuid


netstat2 
打印网络连接、路由表、连接的数据统计、伪装连接以及广播域成员
   Local Address   本地地址和端口
   Foreign Address 远程地址和端口
   state       常见 established listen(首先服务端需要打开一个socket进行监听，状态为LISTEN./*The socket is listening for incoming connections. 侦听来自远方TCP端口的连接请求)
   -a   display all sockets
   -t   tcp协议
   -u   udp协议
   -n   numeric
   -l   display listening server sockets
   -p   display pid/program name for socket 常常lp一块使用
netstat -anlp |grep ssh


nslookup2 
nslookup network.XX.com
Server:		172.28.8.21      dnsServer的地址
Address:	172.28.8.21#53
Name:	network.XX.com         这个域名指向下面的地址
Address: 128.9.61.10


ntp2 ntpq2 
network time protocol
// -p 打印时钟源
ntpq -p 
remote
   * 主同步源
   + 备用同步源
refid
   .init.   初始化中
   .locl.   本地时钟
   .gps.    gps时钟源


ntpdate2 
set the date and time via NTP
// -d debugMode 后面是ntpServer的ipv6
   -r port
ntpdate -d fc00:ac1c::b2a 
ntpdate -d -r 123 10.0.36.6


osi七层    简化4层
应用层 定义客户端与服务端数据交换方式 如http ftp
传输层 定义数据传输方法,主要两种协议 tcp udp 举例http的数据包不允许丢失,因此采用tcp来传输
网络层 使用ip定位目标计算机,采用route决定数据传输路径
链路层 可能是eth,光纤fiber,无线网


pageUp2
// 众所周知,上下键可以切换历史命令,
// 举例:当你敲了ssh 然后pageUp时候,只会展示之前ssh相关的历史命令,好用!!!


passwd2 
// -d delete the password for the named account (root only)
   -S status
   -l lock
   -u unlock
passwd -S testuser
passwd -d root
testuser P 05/15/2024 0 99999 7 -1
各字段详细解释
1	testuser	用户名
2	P	密码状态：
   P：已设置密码（有效）
   L：密码被锁定
   NP：无密码
3	05/15/2024	最后修改密码的日期（MM/DD/YYYY格式）
4	0	密码最小使用天数（修改后必须经过的天数才能再次修改）
5	99999	密码最大有效期（天数，99999表示永不过期）
6	7	密码过期前警告天数（到期前多少天开始提醒用户）
7	-1	密码过期后宽限天数（-1表示禁用宽限期，过期立即失效）


perf2   
// -F freq频率
   -a 采集所有cpu
   -g 记录调用栈
   -- sleep 30 抓30s
perf record -F 99 -ga -- sleep 30 -p Pid  // 指定pid抓       当前目录自动生成perf.data
perf record -F 99 -ga -- sleep 30 -C 0-6  // 指定核范围抓
// -i 指定inputFile                       shift+展开或者收缩
perf report -i perf.data

// -C 0 指定cpu0,2,3,4,6
perf top -g -C 0,2-4,6
// 输出结果里idle可以忽略跳过,主要关注快慢节点上的区别 do_syscall,exc_page_fault
do_syscall代表用户态切到内核执行系统调用,所以这个也是上层排查
exc_page_fault跟内存分配强相关,慢环境上内存剩余约4g,快环境上内存剩余约15G,慢环境上大页占据约9G



pgrep2
pgrep ssh // 只展示ssh进程的pid
pgrep -l ssh // -l 展示 pid 和 processName


pkill2
// 通过进程名字杀进程  -f 代表full process name 
pkill -9 -f /usr/XXX.py


printf2 
// printf formatStr args
printf "first %s %s\n" hello world
printf ":set nu hls cursorline\n" >> ~/.vimrc


// 保存的是bootloader(引导加载程序) 启动linux kernel 时的参数
/proc/cmdline
/proc/meminfo |grep -i huge*


/proc/mounts
cat /proc/mounts |grep root
rootfs / rootfs rw 0 0
/dev/mapper/cpsVG-rootfs / ext4 rw,relatime,i_version,stripe=64,data=ordered,data_err=abort 0 0
fileSys 挂载点 fs类型如ext4 挂载选项 dump备份表示(0不备份,1备份) pass(FS检查顺序,0不检查,1第一个检查,n第n个检查)


trunk2 bond2 
/proc/net/bonding/trunkXXX
   speed   1000Mbps // 网卡最大带宽?小b换算大B要除8
   举例两个网口组成trunk0,可以通过mac找到trunk的网口,比如eth9以前的mac是后面permaddr,组trunk后mac统一变成前面的值,
   10: eth8: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc mq master trunk0 state UP group default qlen 1000
       link/ether ac:dc:ca:7e:a1:e2 brd ff:ff:ff:ff:ff:ff
   11: eth9: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc mq master trunk0 state UP group default qlen 1000
       link/ether ac:dc:ca:7e:a1:e2 brd ff:ff:ff:ff:ff:ff permaddr ac:dc:ca:7e:a1:e3
   254: trunk0: <BROADCAST,MULTICAST,MASTER,UP,LOWER_UP> mtu 1500 qdisc noqueue master ovs-system state UP group default qlen 1000
       link/ether ac:dc:ca:7e:a1:e2 brd ff:ff:ff:ff:ff:ff
       inet6 fe80::aedc:caff:fe7e:a1e2/64 scope link
// 给tunk加减网口
echo +eth5 > /sys/class/net/trunk2/bonding/slaves
echo -eth5 > /sys/class/net/trunk2/bonding/slaves


/proc/pidXXX/fs // ls /proc/pidXXX/fd |wc -l 这种也能统计进程打开的文件数


/proc/pidXXX/oom_score   // 只读,系统计算出来
/proc/pidXXX/oom_adj    // 老参数,作用是兼容
/proc/pidXXX/oom_score_adj // 
Linux下面有个特性叫OOM killer（Out Of Memory killer），这个东西会在系统内存耗尽的情况下跳出来，选择性的干掉一些进程以求释放一些内存。具体的记录日志是在/var/log/messages中，如果出现了Out of memory字样，说明系统曾经出现过OOM
oom_score_adj，用来控制进程打分，分数越高，就先杀谁。oom_score_adj取值范围是-1000到1000，默认值为0。oom_score_adj设为-1000时，表示禁止OOM killer杀死该进程


ps2 
// 查看所有帮助
ps --help a
ps -aux | head -1;ps -aux |grep 889 // 利用head -n ? 显示?行
ps -aux |grep -E "^USER | 889" // 利用正则顺便把USER开头的首行查找出来,但有个缺点如下
ps -ef |grep -E "^UID | 889" // ps 后接不同的选项首行的内容也不相同
// -e Select all processes.  Identical to -A
   -L Show threads, possibly with LWP and NLWP columns
   -o  指定格式,后面单词(官网称之为format specifiers)不能写错
   pid 
   psr 代表processor that process last executed on  进程运行的CPU编号?翻译不够准确?
   cmd 详细命令
   comm 代表command,没卵用,短的很
   cls  scheduling class of the process 
ps -eLo pid,psr,cmd | awk '{if ($2 >= 1 && $2 <= 1) print}'                              // 查出cpu1上跑的进程
// --sort=-rss -rss代表rss数字升序,不写或者写+默认数字升序
ps -aux --sort=-rss |head -9


pstree2 
  -l, --long          don't truncate long lines
  -p, --show-pids     show PIDs; implies -c
  -s, --show-parents  show parents of the selected process
// 无论是替换rm二进制还是ip二进制,玩法都类似
#! /bin/bash
echo $0 $@ >> /tmp/xx.log
pstree -lsp $$ >> /tmp/xx.log
ip.bak $@


pushd popd dirs 目录栈
// 往目录栈top压入 /home 并切到此目录
pushd /home
// 往目录栈top压入 /tmp 并切到此目录
pushd /tmp
dirs // 展示目录栈 /tmp /home
// 不指定参数，则会回到前一个目录，类似cd - ,并把目录栈top的两个目录作交换
pushd 
dirs // 展示目录栈 /home /tmp
// 弹出/home,那不就是切到/tmp
popd


rc.d2 
/etc/rc.d/init.d/                // 存放系统服务脚本
/etc/rc.d/after.local            // 所有系统服务启动后执行的脚本,比rc.local早一些
/etc/rc.d/rc.local               // 系统启动时最后执行的用户自定义脚本


realpath2 
realpath 某文件 // 显示文件路径


reboot2   主机反复重启定位2
原因多样,这里举例np卡引起的定位方法
mv /usr/sbin/reboot /usr/sbin/reboot.bak
printf  '#!/bin/bash\nps -ef >> /root/ps.log' > /usr/sbin/reboot
chmod 777 /usr/sbin/reboot 
mv /usr/sbin/shutdown /usr/sbin/shutdown.bak
printf  '#!/bin/bash\nps -ef >> /root/ps2.log' > /usr/sbin/shutdown
chmod 777 /usr/sbin/shutdown


rm2
rm -r dir0 dir1


route2 
A网络中设备想连B网络中设备,需要借助连接两个网络的某特殊设备发送packet,这个特殊设备叫网关 <shell脚本攻略 6章>
路由表包含了packet如何转发的信息
// -A inet6 指定地址族,不写相当于只展示ipv4的
   -n numeric,
route -A inet6 -n


rpm2 
// -a 查询所有包,但我还是觉得没有grep耗时
   -f 查询哪些包"拥有"此文件
   -l 列出指定软件包的所有文件路径，包括配置文件、二进制文件、库文件等(包名不需要打全,打一部分也可以)
   -R, --requires查询XXX所需依赖
   --changelog 比如你给某个rpm包合入过代码,那么就能用changelog查询到
   --dbpath 举例备区是老版本且人为挂在/mnt下,你想在备区里面查找某个rpm包,那么就得把rpm数据库指向备区
   --nodeps 已有安装1250的包,已上传1260的包,rpm -Uvh 1260的时候总是提示fail dependencies,解决:--nodeps
   --forece 常见于XXX already install,重新强制安装
   -Uvh 升级包,会删除旧包
   -ivh 安装包,不管旧包,同名同版本包例外,会有提示
rpm -qa 
rpm -qa openssh
rpm -qa openssh --dbpath=/mnt/var/log/rpm/
find /lib64/ -name "librdmacm.so.1" // 例如输出/lib64/librdmacm.so.1
rpm -qi XXX.rpm --changelog |less // -i --info list descriptive information from ;-i会多列出包信息,可以去掉
rpm -qf /lib64/librdmacm.so.1
rpm -ql openssh-client-XXX
rpm -qR XXX
rpm -Uvh 1260 --nodeps
rpm -ivh XXX.rpm --force
// --rebuilddb 三步走,一般来说/var/log/rebuilddb.log会记录重建时候把哪些rpm添加到db的idx中
   rpm相关进程大量持锁do_lock_file_write,也是如下三步走
rm -f /var/lib/rpm/__db*
rm -f /var/lib/rpm/*.lock
rpm --rebuilddb


rpmbuild2 



rpm2cpio2 
// 提取rpm包中文件,-v代表verbose
rpm2cpio XXX.rpm | cpio -idv


rsync2
// -r 递归 dir1下面有个a.txt 
rsync -r /home/dir1/ /home/dir2/
// -a 参数可以替代-r，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等） -a archive mode
       The files are transferred in archive mode,
       which ensures that symbolic links, devices, attributes,
       permissions, ownerships, etc. are preserved in the transfer
// -v 代表verbose 至于后面的 用户@ip:目录 类似scp -z代表压缩(网络传输时改善传输效率)
rsync -avz /home/data root@172.X.X.X:/home/back/data


rsyslog2 
/etc/rsyslog.conf +117             // 由此就是人为改成*.err,导致message,libvirt,sysmonitor等全部日志都不打印了
*.debug;mail.none;authpriv.none;cron.none                :omfile:$message
1. 日志过滤规则
*.debug
捕获 所有设施（facility） 且 日志级别为 debug 及以上（即所有日志，因为 debug 是最低级别）。
* 表示所有设施（如 kern、auth、cron 等）。
.debug 表示日志级别为 debug（包括 debug、info、notice、warning、err、crit、alert、emerg）。
排除规则（; 分隔）
mail.none：忽略邮件相关日志（mail 设施）。
authpriv.none：忽略敏感认证日志（如 SSH、sudo，通常单独存储到 /var/log/secure）。
cron.none：忽略计划任务日志（cron 设施，通常单独存储到 /var/log/cron）。
2. 日志存储方式
:omfile:$message
omfile：表示使用 文件输出模块（Output Module File）。
$message：将日志的原始消息内容写入文件（不附加额外元数据如时间戳、主机名等）。
默认情况下，日志会写入 /var/log/messages（具体路径由全局配置决定）。


scp2 
// ipv4 当时从已登录的单板9.11...上传了证书(被改名为github.cer)到自己的单板9.13...上
   -r 递归整个目录 
scp -P 端口 github.cer 多文件空格分隔 9.13.7.128:/etc/pki/ca-trust/source/anchors/	
scp -P 端口 -r /home/ 9.13.7.128:/home/	
scp github.cer 多文件空格分隔 [2003:0:d05:225::26]:/etc/pki/ca-trust/source/anchors/	                        注意ip与目录之间别漏了 冒号 ::::::::::
// 只要本机能ping通198,就能从198上远程拷贝日志到本机当前目录
scp hyj@198.91.130.161:/home/hyj/a.log ./
// scp对Strict有严格顺序要求
scp -r -o StrictHostKeyChecking=no /boot/efi/*  172.0.0.1:/boot/efi


sed2 
(stream editor相比于vim文本编辑器就不多解释了吧),sed每次读取一行到它自己缓冲区,然后在缓冲区做操作,最后输出 https://www.gnu.org/software/sed/manual/sed.html
格式 sed option script file
script举个例子 s/oldStr/replacement/flags
// -i 代表in-place        直接修改源文件(看情况加), s代表substitute替换脚本,
   -e 代表expression      执行多个命令可以用-e
   -f 代表file            命令多到需要额外一个脚本文件来记录 script.sed
sed -i 's/is a/is not a/g' /home/a.txt
sed -e 's/big/Big;s/small/Small' /home/a.txt
sed -f script.sed /home/a.txt

// a 新增下一行 常用编辑命令
   d 删除
   s 替换,简单略
   i 插入
   p 打印,通常与-n配合,suppress output,抑制sed默认打印
sed -i '/999/a 101010/' a.txt
sed '1p' test.txt的输出​​：
line1  <-- p命令显式打印第一行
line1  <-- sed默认打印第一行
line2  <-- sed默认打印第二行（第二行不匹配1p，故p命令未执行）
​​sed '2p' test.txt的输出​​：
line1  <-- sed默认打印第一行（第一行不匹配2p，故p命令未执行）
line2  <-- p命令显式打印第二行
line2  <-- sed默认打印第二行

sed -n  '1p ; $p' one.txt two.txt three.txt // sed treats multiple input files as one long stream.1p打印输入流第一行,$p打印输入流的最后一行(实测是three.txt的最后一行)


selinux2 getenforce2 
selinux是安全子系统,它通过为系统资源（如文件、进程、端口）定义严格的访问策略，来增强 Linux 系统的安全性
// 查看selinux运行模式
   Enforcing（强制模式）：严格执行安全策略，拒绝违规操作。
   Permissive（宽容模式）：仅记录违规行为但不阻止，用于调试。
   Disabled（禁用）：完全关闭 SELinux
getenforce


sh2 
// -c 把后面字符串当命令执行 https://blog.csdn.net/weixin_53389944/article/details/136560945
sh -c 'XXX'
// -x 进入跟踪方式，显示所执行的每一条命令
sh -x a.sh > /home/t.txt // 我发现文本没内容
sh -x a.sh 2>&1 > /home/t.txt
sh -x a.sh > /home/t.txt 2>&1
sh -x a.sh &> /home/t.txt // &在这不是后台运行命令,注意 &> 要相连,&>：是 > 和 2>&1 的组合写法，表示 同时重定向 stdout（标准输出）和 stderr（标准错误）



size2 
size命令用于查看目标文件、库或可执行文件中各段及其总和的大小，是 GNU 二进制工具集 GNU Binutils 的一员。
size hello.o
[root@localhost test]# size hello.o
   text	   data	    bss	    dec	    hex	filename
    115	     80	      0	    195	     c3	hello.o


sleep2 
// s m h d,秒分时天,不写默认单位秒
sleep 2d


soft lockup 软锁  hard lockup 硬锁  触发panic机制
软锁 cpu被内核代码占据
硬锁 cpu被内核代码占据,且不响应中断

sort2 
// 通常配合uniq去重统计使用,-c统计个数,作为结果第一列
sort | uniq -c
// -t 指定字段分隔符 
   -k 指定第三列排序(字典序?短,小,升序,平时使用总是按数字排序,所以-n少不了的) 
   -n 按数字默认升序
   -r 降序
sort -t ':' -k 3 -n /etc/passwd


source2
它会将脚本中的命令直接加载到当前 Shell 中执行,而不是新的子shell
sh2区别
sh 命令用于启动一个新的子 Shell 来执行脚本文件


strace2 
琦哥:strace抓系统调用:用户态陷入到内核态,vhost线程已经是内核态进程,strace抓个毛
// -T 显示每一调用所耗的时间. 
   -t 在输出中的每一行前加上时间信息. 
   -tt 在输出中的每一行前加上时间信息,微秒级. 
   -ttt 微秒级输出,以秒了表示时间. 
   -f 观察fork子进程啥的,
   -o 指定输出文件 
   -p 指定进程号
strace -o /home/fsp/hyj.txt -f -tt rpm -evh hinic-5.5.0.15_XX
strace -o a.txt -Tttt -p 73010 


string2
从二进制中提取字符串的工具
string /usr/lib64/libc.so.6 |grep GLIBC    最高支持2.38??


return2
return: can only `return' from a function or sourced script,退出当前函数,不是退出整个脚本,return和break什么区别不用重复了吧
exit2
终止shell脚本执行,可以在脚本任何地方使用


ssh-keygen2 
// -C 为密钥添加注释,通常用于标识密钥的用途或所有者
// -t 指定密钥类型,可选值为dsa、ecdsa、ed25519、rsa,默认为rsa   所以-t rsa没必要加了
// 然后把id_rsa.pub的内容加到github中就行了
ssh-keygen -C XXX@163.com


ssh2 
ssh root:passXXX@10.189.4.183:35

sshd_config2 
ssh_config主要关注客户端如何连接到SSH服务器，‌
sshd_config则关注SSH服务器如何配置以响应这些连接请求
sshd_config中的ListenAddress 指定 SSH 服务器监听的 IP 地址
假设服务器有2个网卡,一个连内网(假设ip 192.168.1.11),一个连外网(假设ip 192.168.1.22),如果只监听内网网卡ip的话,可以减少外部攻击的风险
// 可以观察到ssh监控的ip
netstat -tunlp |grep ssh

// 问题1,假设listenAddress监听两个ip,上面命令只查出来一个
首先systemctl status sshd 确认sshd服务拉起时间
message日志bind to port 22 on XX failed: cannot assign requested address
sysmonitor日志eth4: ip[172.28.0.4] prefixlen[20] is added,
正确时序:先ip被添加,sshd服务拉起后才会根据listenAddress去监听ip
为啥绑定报错->因为ip不存在->为啥不存在->dhcp还没获取到这个ip地址
// 实测AllowUsers不添加root,root没法登陆
PermitRootLogin yes
AllowUsers XX root
// -v verbose mode
ssh -v my@127.0.0.1

// 问题2,stop sshd服务后,修改/usr/lib/systemd/system/sshd.service中的Restart=no,期望ssh不在拉起,但ssh还是快速被拉起,sysmonitor.log记录是某个脚本拉的
复制一行ExecStart
ExecStart=exit 0
Restart=no # 表示systemd不会去拉起sshd,和sysmonitor两码事?


stat2 
输出中modify与change的区别
modify`时间戳表示文件的内容最后一次被修改的时间，即文件内容的修改时间。
change`时间戳表示文件的元数据最后一次被修改的时间，即文件权限、所有权、链接等元数据的修改时间
size 4096 linux中目录的size通常为4096,或者4096倍数?


strace2
// -t           在输出中的每一行前加上时间信息。
   -tt          在输出中的每一行前加上时间信息,微秒级。
   -ttt         微秒级输出,以秒了表示时间。
strace -o /home/fsp/hyj.txt  -tt rpm -evh XX.rpm


su2 
// 不写用户,默认切root,环境变量还是当前用户的
su 
// 不写用户,默认切root,环境变量是root 用户的   https://www.cnblogs.com/linyfeng/p/13511945.html
su -


sudo2 
// sudo诞生前,su的缺点是要输入root密码,sudo使一般用户不需要知道超级用户的密码即可获得权限。首先超级用户将普通用户的名字、可以执行的特定命令、按照哪种用户或用户组的身份执行等信息，登记在特殊的文件中（通常是/etc/sudoers


/sys/fs/cgroup/cpuset/cgroup.procs                                    决定哪些进程只能使用指定的 CPU 核心，就像给进程分配固定的“工作座位”。
// 把当前shellPid写入它里面,允许当前shell使用cpu
echo $$ >> /sys/fs/cgroup/cpuset/cgroup.procs
CPU 核心 = 办公桌（比如 4 张桌子对应 4 个 CPU 核心）
cpuset = 你给不同项目组划分的专属办公区（比如：A 组只能用 1-2 号桌，B 组用 3-4 号桌）
cgroup.procs = 贴在办公区门口的成员名单，只有名单上的人才能进这个区域工作
/sys 是内存虚拟文件系统
   /sys/fs/cgroup/ 下的文件仅存在于内存中，由内核动态生成
   所有修改不会写入磁盘，重启后内核会按默认配置重建
进程生命周期绑定
   echo $$ 操作仅对当前Shell进程有效
   若Shell退出（如关闭终端），进程自动移出该cgroup
   子进程不会继承这一设置（除非显式配置）
cgroup 的临时性设计
   默认cgroup规则是会话级（session）的临时控制
   持久化需要借助管理工具（如systemd、cgconfig）


sysctl2 
// 显示所有系统参数,NMI中断采样频率降低,说明主机性能差,NMI处理时间变长,系统会自动降低此频率
sysctl -a |grep perf_event_max_sample_rate 
sysctl -a |grep panic |grep oom
// 关闭oom时panic
sysctl -w vm.panic_on_oom = 0


/sysroot2 
最终系统根目录 (/)	毛坯房（未来要住的房子）
/sysroot	临时工棚（存放装修工具和材料）
PXE启动时：
   你的电脑像一块空地，通过网络加载临时系统（工棚）。
   这个临时系统把真正的系统安装包（瓷砖、油漆）放到 /sysroot 里准备装修。
安装过程中：
   安装程序把 /sysroot 里的文件"装修"到目标磁盘（毛坯房）。
   完成后，/sysroot 会被卸载，最终系统从磁盘上的 / 启动。


systemctl2 
systemctl status hkids
○ hkids.service - hkids deamon server
     Loaded: loaded (/usr/lib/systemd/system/hkids.service; enabled; vendor preset: disabled)
// 上面enabled代表hkids服务开机自启
systemctl enable hkids
// 开启udev debug级别,新增打印设备匹配udev规则
vim /etc/udev/udev.conf 打开注释行,并把info改成debug    
systemctl daemon-reload
systemctl restart systemd-udevd
systemctl cat sshd



systemd-analyze set-log-level debug
systemd-analyze set-log-level info
systemd-analyze blame // 展示各阶段耗时


tail2 
tail -f message |grep sshd
cat XX.txt |tail -9


tar2 
// -c compress压缩某个目录
   -z 使用gzip,XXX.tar.gz的话,一般加个它    坑:如果用z,z写最前面
   -x extract抽取
   -C 解压到目标目录下
tar -cvf XXX.tar /home/
tar -cvf XXX.tar /home/a.txt /home/b.txt
tar -zcvf XXX.tar.gz /home/
tar -zxvf  XXX.tar.gz  -C  ./
命令末尾写法	         含义                  是否含隐藏文件	是否保留目录层级
*	         仅打包当前目录下的非隐藏文件/目录	❌	         ❌
./*	      同上（* 默认不匹配隐藏文件）	      ❌	            ❌
.	打包当前目录内容（含隐藏文件），但路径记录可能不一致（依赖实现）	✔️	  ⚠️可能不保留
./.	明确打包当前目录本身+全部内容（含隐藏文件），强制保留完整路径(解压时你就懂了)	✔️	✔️


taskset2 
taskset -c 1,3,5-7 /home/a.sh
taskset -cp 3960447 // 举例查询qemuPid的核
pid 3960447's current affinity list: 40-47
// 当然也可以指定进程绑核范围
taskset -cp 0,3  1393 
pid 1393's current affinity list: 0,4
pid 1393's new affinity list: 0,3
// 常见报错,绑核失败,
taskset -cp 40  11940
pid 11940's current affinity list: 0-11,28-39
taskset: failed to set pid 11940's affinity: Invalid argument
// 接上,这个进程的cpuset位于system-hostos.slice下面
cat /proc/11940/cgroup
...
8:cpuset:/system.slice/system-hostos.slice
// 范围没有40
cat /sys/fs/cgroup/cpuset/system.slice/system-hostos.slice/cpuset.cpus
0-11,28-39
// 注意:父cgroup的约束,不能乱echo
cat /sys/fs/cgroup/cpuset/system.slice/cpuset.cpus
0-55
echo '40,42-44' > /sys/fs/cgroup/cpuset/system.slice/system-hostos.slice/cpuset.cpus


tcpdump2 
格式:tcpdump option protocol diretion type                              https://www.cnblogs.com/wongbingming/p/13212306.html
proto取值         传输层网络层协议可以ip ip6 icmp tcp udp,应用层协议不行http https dns ssh这些一般用特定的port过滤
direction取值   src dst 
type取值         host 127.0.0.1 
                  net127.0.0.1/8 
                  port22 
                  portrange 22-24
输出格式:时分秒毫秒 协议(ivp6/ip)  src的ip+port > dst的ip+port 数据包内容
// -v verbose -v -vv -vvv
   -nn 单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。这样不仅方便查看 IP 和端口号，而且在抓取大量数据时非常高效，因为域名解析会降低抓取速度。
   -e  显示数据链路层信息。默认情况下 tcpdump 不会显示数据链路层信息，使用 -e 选项可以显示源和目的 MAC 地址，以及 VLAN tag 信息
   -i 指定interface, -i any就是指定所有网口(物理网卡可能有多个网口,例如eth2)
   -w 指定输出文件
   [src/dst] host 192.XX 感觉host+ip固定写法吧,host不关心src/dst之类的
tcpdump -vvv -i any -w /home/a.pcap  host 192.168.0.1 and port 443 
tcpdump -i trunk0 -nne 
tcpdump -vvv -i enp129s0f0 -w XXX.pcap
// 源端ssh连不上目的,|info|sshd[2054272]|Connection from fc51:158:46:17::32 port 58890 on fc00:0:0:2621::2 port 22 rdomain ""
   1 先确定目的端ip对应的网口名字叫external_api,然后目的端敲命令如下
tcpdump -i external_api  -vvv   |grep fc51:158:46:17::32


tmpfs2
临时文件系统,驻留在内存中,比如常见的 /run
// 多分区只读,message无法vim,则可以拷贝至内存中,再查看message
cp message /run


top2 
动态检测进程运行状态      帮助:直接敲top,按h,实际帮助不大
// 按1  查看所有cpu占用详情
   按E  切换K M G T // 注意 Mem前有单位变化,单位过小会导致某值末尾+现象(仅仅是数字太大又展示不全,所以展示加号)    XXX+ total,     XXX+ free,     XXX+ buff 
   按f  自定义top展示字段    
   按M  内存使用率排序,效果: 按RES列(进程使用物理内存==resident内存 kB)降序
   按P  根据cpu排序 
top -M
hi hardIrq硬中断
si softIrq软中断(与收发包有关,具体看sar日志)


tty2 
systemctl status getty@tty1
systemctl status getty@tty2


tune2fs2 
// filesystem state:clean还是clean with errors,所以此clean与fsck提示中still have error并不冲突
   clean with errors 文件系统已经正常解挂(有挂载点,ai还说已经正常解挂?),但是存在些许err,下次挂载的时候会自动fsck
   clean	文件系统已正常卸载（无未修复的错误）。	正常关机或手动 umount 后。
   dirty	文件系统未正常卸载（可能存在未同步的元数据或错误）。	强制重启、崩溃、断电等异常情况。
   errors	文件系统已标记为存在错误（需手动修复）。	检测到不一致时（如 fsck 未完成修复）
   -m reserved block count percentage 通常(5%==计算方式reserved block count/block count),预留是去占用size-avail之间的空间,预留不是去占用size的大小
tune2fs -l /dev/mapper/rootfs
tune2fs -m 5 /dev/mapper/rootfs


uefi2    legacyBios(老技术都快淘汰了)
ls /sys/firmware/efi 
/boot/efi/EFI/XXX/grub.cfg                             uefi
/boot/grub2/grub.cfg                            legacy


ulimit2 限制进程core
ulimit -a // 强烈推荐这个
 open files // 进程打开的文件数量限制
ulimit // 直接查看core文件大小,返回unlimited代表core文件大小无限制
ulimit -c 1 // 设置core文件大小,单位blocks,block==1024字节
ulimit -c unlimited // 设置core文件大小无限制
强关联内容core_pattern
cat /proc/sys/kernel/core_pattern
/var/log/idump/core_%e_%p_%t // 代表默认生成的core文件在此目录下,且格式是"下面讲解"https://man7.org/linux/man-pages/man5/core.5.html
%e  The process or thread's comm value, which typically is the same as the executable filename 
%p  core掉的pid
%t  core掉的time


umask2 
umask（用户文件创建掩码）是一个重要的权限管理机制，用于控制新创建文件和目录的默认权限
最终权限 = 默认最大权限 & ~umask
文件：默认最大权限为 666（rw-rw-rw-）
如果umask==022 ,快捷计算规律:文件默认权限==666-022==644
目录：默认最大权限为 777（rwxrwxrwx）
如果umask==022 ,快捷计算规律:文件默认权限==777-022==755


umount2 
// -l --lazy detach the filesystem now, and cleanup all later
   系统会立即断开挂载点的目录树，但实际的文件系统卸载会延迟到所有相关进程结束访问后再完成。这允许你卸载一个“繁忙”的文件系统，而无需先终止所有占用它的进程。
   典型使用场景：
      强制卸载被占用的挂载点：
      例如，当你无法直接卸载 NFS 共享或外接硬盘（因为有进程卡死或无法终止），可以用 umount -l 先解除挂载点，后续由系统自动处理残留的访问。
      避免阻塞操作：
      某些情况下（如网络存储不可达），常规卸载可能卡住，-l 可以立即返回，让卸载在后台完成
   -v verbose
   -f --force
umount -lv /var/log


uname2 
uname -a // unixName 通常带-a 显示系统信息(内核版本啥的)
uname -r // 直接查看内核版本


uptime2 
// 18:29:58->当前系统时间, 23:12->已经跑了7天23小时12分钟，当前只有1个用户登录，系统在最近1分钟、5分钟、15分钟内的平均负载分别为0.00、0.01、0.05
18:29:58 up 7 days, 23:12,  1 user,  load average: 0.00, 0.01, 0.05
// -s, --since    system up since
uptime -s


useradd2
// -m 创建用户家目录
   -s 指定新用户登录时所用shell /bin/false表示禁用用户登录系统
   -M 不创建用户homeDir
useradd -m XXX -s /bin/false 
   passwd XXX
   vim /etc/ssh/sshd_config // AllowUsers行尾添加XXX
   systemctl restart sshd


userdel2
// -r 删除用户家目录和mail spool(卷轴,卷盘)
userdel -r XXX


usermod2 
// 把hyj用户的家目录(默认/home/hyj)move到/home/hyj2目录下   实测细节:新的目录不能存在,存在会报错提示,用户的老家目录会删除,一创一删给人感觉就是老家目录换了个目录名字
usermod -md /home/hyj2 hyj


/var/log/secure
密码的改动会被记录,如 password changed for XXX


// 常常通过ssh从首节点跳转到其他节点,其他节点过一会会自动退出,但自己又不是守在屏幕前,所以不清楚是目前首节点还是其他节点
who


wget2 
// XX.tar.gz.sha256sum这个文件一般较小,下载完后右键可以copy download link,然后把链接的.sha256sum直到末尾全删掉就是tar.gz的下载链接了
   --no-check-certificate 
wget XX.tar.gz
wget --help |grep certi


xargs 
// 给命令传递参数,怎么传递的就很迷
// 常常用来umount前杀进程
lsof -t /var/log |xargs kill -9 
// 多行输出
lsof -t /var/log |xargs cat
// 一行输出
lsof -t /var/log |xargs ll
// 多行输出
lsof -t /var/log |xargs ls -s 


yum2 
// 配置仓库/etc/yum.repo.d/??.repo
yum search git
// 查询某个包的来源,字段from repo
yum info git
yum install git
       import rpmUtils.updates  // 报错就是rpm包中相应的update.pyc update.py文件搞坏了,规避:rpm -Uvh yum同版本包
   ValueError: bad marshal data (unknown type code)

yum list installed |grep git*
yum remove git
yum provides ld // 由此编东西提示ld缺失,以为是binutils包里面的,实际是binutils-extra包里面的(provides含金量来了!!!)
// 通常添加或者删除XXX.repo后,需要一下两步骤
yum clean all // 删除yum缓存中可用包和旧缓存,yum clean删除前者
yum makecache // 生成缓存
// 从本机的yum源中下载httpd软件包
yumdownloader httpd


grep2 
grep "ip_local_reserved_ports" -nr /usr/lib		// -n 显示num  -r 递归目录
lsof -i:49208  // 山哥说只要有输出,本机在用此端口,   770是指对端ip
netstat -tunlp 49208
sysctl -a | grep ip_local_reserved_ports // -a 显示所有的系统参数
ip a  // Linux系统中用于查看IP地址信息的命令


timeout2 
// Usage: timeout [OPTION] DURATION COMMAND [ARG]...
// -s 发送signal 如果600s内reboot命令没执行完,则发送 KILL 信号,终止reboot命令
timeout -s KILL 600 reboot 
// ping会一直ping的,下面这个就很好理解,让它ping 2秒后就kill掉
timeout -s KILL 2 ping www.baidu.com


unzip2 
// -d extract files into exdir
unzip XX.zip -d /dirXX


watch2 
监视命令
// -d 高亮变化差异
   -n2 采样间隔2sec
watch -d -n2 'ps -ef |grep systemd |grep -v grep'


wc2 
// -l line counts统计行
wc -l XXX.txt
XXX |wc -l


zgrep2 
// -a  --text equivalent to --binary-files=text      treat all files as text
zgrep -an "TLS handshake" ./logdump*


& 表示任务后台执行，与nohup命令功能差不多。   通常放在命令的末尾
&& 表示前一条命令执行成功时，才执行后一条命令。
|| 表示上一条命令执行失败后，才执行下一条命令。
