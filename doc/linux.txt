/etc/profile.d/
包含系统级别脚本,用户登录时被执行

个人配置文件      ~/.bashrc           敲alias展示结果来源于此
`~/.bashrc` 是 Bash shell 的配置文件，它包含了一些用户自定义的环境变量、别名、函数和命令等。当用户登录到一个 Bash shell 时，Bash 会自动执行 `~/.bashrc` 文件中的命令，
以设置用户的环境变量和自定义命令等。这个文件通常用于设置用户的个性化环境，比如设置命令别名、添加 PATH 环境变量、定义 shell 函数等。
rc 代表run command,类似的还有~/.vimrc 我喜欢默认加上:set nu hls
注意             改完记得source file // source命令 "从file中读取并执行命令"

&&  第一个命令退出码0才执行第二个命令,以此类推
确认I层内存总体使用量，命令：cd /sys/fs/cgroup/memory/system.slice/fsp && cat memory.usage_in_bytes && cat memory.limit_in_bytes

/etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin // 7列
logName:密码全部用X代替:uid:gid:userName:homeDir:用户登陆后默认的shell程序
真实密码在/etc/shadow中,加密串,不是明文,好像也没啥卵用
/sbin/nologin 或者 /bin/false 代表禁止此用户默认登录


chage -l root // list account info
Last password change					: Nov 10, 2023
Password expires					: Feb 08, 2024
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 90
Number of days of warning before password expires	: 7

 
chown root:root b.txt // 改变文件的所有者:所有者组
chown root a.txt //
chown :root c.txt //

linux 2个特殊的文件 /dev/null /dev/zero
/dev/null  ： 在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。
/dev/zero  ： 在类UNIX 操作系统中, /dev/zero 是一个特殊的文件，当你读它的时候，它会提供无限的空字符(NULL, ASCII NUL, 0x00)。

dd命令
dd if=/dev/zero of=/mnt/test bs=1M count=10 oflag=direct
if      input file
of      output file
ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。
obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。
bs=bytes：同时设置读入/输出的块大小为bytes个字节。
iflag=direct 绕开fs的缓存
oflag=direct

df -h // disk free
du -hs // diskUsage,默认显示当前目录,-s 总结      显示当前目录总大小
du -hs * // 显示当前目录,每个子项的大小

ethtool
ethtool -i eth0 // 显示网卡eth0的驱动信息
ethtool -P eth0 // 显示 permanent Addr ,也称 hardware Addr,也称 MAC
link detected:no // 2层链路状态,通俗来说就是物理网线没插,这种就不需要关注上层3层,如ifconfig up/down属于3层

// export命令声明了将由子进程所继承的一个或多个变量。这些变量被导出后，当前shell脚本所执行的任何应用程序都会获得这个变量。
// 在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。
linux配置path,全用户有效,举例:配置rust的path
vim /etc/profile
export PATH="$PATH:~/.cargo/bin"
export -p //列出当前的环境变量值
source /etc/profile

find / -name uvp-getosstat -type d 2>/dev/null  // -type d只查找目录 2>/dev/null标准错误流向"无底洞",也就是丢弃错误信息

fsck
fsck -y /dev/sda
fsck -nf /dev/sda // -n表示以只读模式运行`fsck`，即不对文件系统进行任何实际的修复操作 -f表示强制运行`fsck`，即使文件系统被标记为“干净”（clean），也会进行检查和修复

grep 高级实操
背景 大概找一下下面这个宏是哪些补丁用到了,假设有(对比开源版本的商用的版本的补丁),看是不是漏打补丁了
#ifndef OPENSSL_FIPS         // ndef==not defined 这个宏没有定义
# error FIPS is disabled.
#endif
/// -r递归目录(grep最后可以接单个文件,多个文件,或者目录配合-r) -n显示行号 -w单词匹配 -v反转查找
/// 当前目录下有很多补丁,从补丁从查找谁用到openssl_fips这个宏,并且把ifdef给排除掉,最后一个grep仅仅是为了颜色高亮,因为第二个grep -v会把高亮抹掉
[root@localhost openssl_virtual]# grep -rnw OPENSSL_FIPS ./ | grep -v ifdef | grep OPENSSL_FIPS        //r递归目录 n行号 w单词匹配  E拓展表达式 v取反

-A3     // 多展示后面3行
-B3     // 多展示前面3行
-C3     // 多展示后面前后各3行

ip a
ip是个很强的命令,有很多子命令如 ip addr      ip link      ip route 等
ip a show eth0
10: eth0: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1800 qdisc mq master trunk2 state UP group default qlen 1000
    link/ether a4:6d:a4:90:3d:5e brd ff:ff:ff:ff:ff:ff
10          编号10,从1开始没啥好说的
UP          表明eth0被启动,逻辑上 // 例如有次pxe报错dhclient enpXXX failure,ip a show显示这个enpXXX网卡呢没有up,lower_up,只能通过ethtool查看这个网卡的2层链路状态
LOWER_UP    表明eth0物理链路上已连接
mtu==max trans unit最大传输单元   单位是字节
qlen 1000    接收队列的长度为1000
link/ether a4:6d:a4:90:3d:5e   该接口的MAC地址
brd ff:ff:ff:ff:ff:ff   广播地址

ip a s // 感觉这两个命令用来查询网卡信息,没区别呀...
ip link set eth5 vf 4 rate 1000  这条命令具体什么意思?
这条命令的意思是将物理网卡 eth5 的第 4 个虚拟网卡的带宽限制为 1000 Mbps。其中，ip link set 是设置网络接口的命令，eth5 是物理网卡的名称，vf 4 表示要设置的是第 4 个虚拟网卡，rate 1000 表示设置带宽限制为 1000 Mbps



iostat -dmx 1 5 /dev/sda /dev/sdb（1代表每隔1s刷新一次，5代表总共显示5次，/dev/sdx代表要显示的盘符）
iostat -dx 1 // 每1秒刷新一次,无效刷
-d 只显示disk统计信息
-m 已 MB 单位显示
-x 展示拓展信息

journalctl
journalctl -u sshd	// 用于查看系统日志的工具 没有收到包  用于查看指定服务的日志。其中 `-u` 参数指定了要查看的服务的名称，例如 `journalctl -u ssh
应用场景:cps host-list显示虚拟机fault,查看journalctl日志发现rootfs没挂上去?或者fsck失败?手动fsck
journalctl -f -u sshd // -f 展示最新日志 journal杂志,日志  entry[n]记录,词条 journey[n v]旅游

ldconfig
ldconfig 命令用于在默认搜寻目录 /lib 和 /usr/lib 以及动态库配置文件 /etc/ld.so.conf 内所列的目录下，搜索出可共享的动态链接库（格式如 lib*.so*），进而创建出动态链接器（ld.so 或 ld-linux.so）所需的缓存文件。缓存文件默认为 /etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表。为了让动态链接库为系统所共享，需运行动态链接库的管理命令 ldconfig 更新动态链接库的缓存文件。
附
/proc/sys/vm/drop_caches 是一个系统文件，它允许用户在 Linux 操作系统中清除内核缓存。这个文件包含一个整数，它控制哪些缓存应该被清除。具体来说，这个整数的值可以是以下之一：
- 0：什么都不清除(默认)
- 1：清除页缓存。
- 2：清除目录项和inode缓存。  dentries and inodes   如何理解dentries??
- 3：同时清除页缓存、目录项和inode缓存。
---
echo 3>/proc/sys/vm/drop_caches
rm -f /etc/ld.so.cache
ldconfig
---

mount
mount -o remount,ro /dev/mapper/cpsVG-image
-o 后面接逗号分割options,remount选项代表重新挂,ro选下来代表只读,整体意思是:将一个已经挂下的档案系统重新用不同的方式挂上。例如原先只读的系统，现在以可读写的模式重新挂上

mpstat [-P {|ALL}] [internal [count]]
参数 解释
-P {|ALL} 表示监控哪个CPU， cpu在[0,cpu个数-1]中取值
internal 相邻的两次采样的间隔时间、
count 采样的次数，count只能和delay一起使用
mpstat -P 8,9,10,11 2 // 每个两秒,监视cpu8,9,10,11的数据

netstat
localAddr   本地地址和端口
foreignAddr 远程地址和端口
state       常见 established listen(首先服务端需要打开一个socket进行监听，状态为LISTEN./*The socket is listening for incoming connections. 侦听来自远方TCP端口的连接请求)
-p   多展示一列 pid/programName
-n   上面两个地址替换成ip
-t   tcp协议
-u   udp协议
-l   display listening server sockets

pgrep
pgrep ssh // 只展示ssh进程的pid
pgrep -l ssh // -l 展示 pid 和 processName


// 保存的是bootloader(引导加载程序) 启动linux kernel 时的参数
/proc/cmdline
/proc/meminfo |grep -i huge*

/proc/mounts
cat /proc/mounts |grep root
rootfs / rootfs rw 0 0
/dev/mapper/cpsVG-rootfs / ext4 rw,relatime,i_version,stripe=64,data=ordered,data_err=abort 0 0
fileSys 挂载点 fs类型如ext4 挂载选项 dump备份表示(0不备份,1备份) pass(FS检查顺序,0不检查,1第一个检查,n第n个检查)


/proc/pidXXX/oom_score   // 只读,系统计算出来
/proc/pidXXX/oom_adj    // 老参数,作用是兼容
/proc/pidXXX/oom_score_adj // 
Linux下面有个特性叫OOM killer（Out Of Memory killer），这个东西会在系统内存耗尽的情况下跳出来，选择性的干掉一些进程以求释放一些内存。具体的记录日志是在/var/log/messages中，如果出现了Out of memory字样，说明系统曾经出现过OOM
oom_score_adj，用来控制进程打分，分数越高，就先杀谁。oom_score_adj取值范围是-1000到1000，默认值为0。oom_score_adj设为-1000时，表示禁止OOM killer杀死该进程

ps查找进程时顺保留首行
ps -aux | head -1;ps -aux |grep 889 // 利用head -n ? 显示?行
ps -aux |grep -E "^USER | 889" // 利用正则顺便把USER开头的首行查找出来,但有个缺点如下
ps -ef |grep -E "^UID | 889" // ps 后接不同的选项首行的内容也不相同

realpath 某文件 // 显示文件路径

rpm
rpm -qa // 查询所有包
find /lib64/ -name "librdmacm.so.1" // 例如输出/lib64/librdmacm.so.1
rpm -qf /lib64/librdmacm.so.1 // 查询哪些包"拥有"此文件
rpm -ql openssh-client-XXX // 列出指定软件包的所有文件路径，包括配置文件、二进制文件、库文件等(包名不需要打全,打一部分也可以)
// 已有安装1250的包,已上传1260的包,rpm -Uvh 1260的时候总是提示fail dependencies,解决:--nodeps
rpm -Uvh 1260 --nodeps

scp
// 当时从已登录的单板9.11...上传了证书(被改名为github.cer)到自己的单板9.13...上
scp github.cer 多文件空格分隔 9.13.7.128:/etc/pki/ca-trust/source/anchors/	

sh -x // 进入跟踪方式，显示所执行的每一条命令
sh -x a.sh > /home/t.txt // 我发现文本没内容
sh -x a.sh &> /home/t.txt // &代表后台运行命令,注意 &> 要相连,多空格文本会无内容!!!

size命令
size命令用于查看目标文件、库或可执行文件中各段及其总和的大小，是 GNU 二进制工具集 GNU Binutils 的一员。
size hello.o
[root@localhost test]# size hello.o
   text	   data	    bss	    dec	    hex	filename
    115	     80	      0	    195	     c3	hello.o

// -C 指定解压后目录
tar -zxvf  ?.gz  -C  ./

top命令   动态检测进程运行状态
有点特殊,直接敲top,帮张信息按h查看,但似乎没用??
top -M // 按内存使用率排序,效果: 按RES列(进程使用物理内存)降序
按1  查看所有cpu占用详情
按P  根据cpu排序
按E  切换K M G T
按f  自定义top展示字段


ulimit
ulimit // 直接查看core文件大小,返回unlimited代表core文件大小无限制
ulimit -c 1 // 设置core文件大小,单位blocks,block==1024字节
ulimit -c unlimited // 设置core文件大小无限制
强关联内容core_pattern
cat /proc/sys/kernel/core_pattern
/var/log/idump/core_%e_%p_%t // 代表默认生成的core文件在此目录下,且格式是"下面讲解"https://man7.org/linux/man-pages/man5/core.5.html
%e  The process or thread's comm value, which typically is the same as the executable filename 
%p  core掉的pid
%t  core掉的time


uname
uname -a // unixName 通常带-a 显示系统信息(内核版本啥的)
uname -r // 直接查看内核版本

// 常常通过ssh从首节点跳转到其他节点,其他节点过一会会自动退出,但自己又不是守在屏幕前,所以不清楚是目前首节点还是其他节点
who

/etc/yum.repo.d/??.repo
yum search git
yum install git
yum list installed |grep git*
yum remove git



grep "ip_local_reserved_ports" -nr /usr/lib		// -n 显示num  -r 递归目录
lsof -i:49208  // 山哥说只要有输出,本机在用此端口,   770是指对端ip
netstat -tunlp 49208
sysctl -a | grep ip_local_reserved_ports // -a 显示所有的系统参数
ip a  // Linux系统中用于查看IP地址信息的命令

/etc/fstab
磁盘被手动挂载之后都必须把挂载信息写入/etc/fstab这个文件中，否则下次开机启动时仍然需要重新挂载。 系统开机时会主动读取/etc/fstab这个文件中的内容，
根据文件里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了。

timeout -s KILL 600 reboot // 执行reboot命令(或其他脚本),只让他执行600s,超过600s后向命令(或脚本)发送-s KILL 信号

zgrep -a "TLS handshake" ./logdump*
-a, --text
treat all files as text

& 表示任务后台执行，与nohup命令功能差不多。   通常放在命令的末尾
&& 表示前一条命令执行成功时，才执行后一条命令。
|| 表示上一条命令执行失败后，才执行下一条命令。
