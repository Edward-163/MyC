我在每个命令后面加个2只是方便搜索
bios自检            检查硬件是否正常
bootloader引导程序  grub就是其中之一
grub加载内核和initramfs            bootloader加载内核文件(/boot/vmlinuz-5.10.0-136.12.0.86.h2196.x86_64包含内核启动代码和必要的驱动)到内存中
内核启动启动并解压initramfs         (/boot/initramfs-5.10.0-136.12.0.86.h2196.x86_64.img临时文件系统,包含linux系统所需驱动和必要文件) 到内存中，并执行其中的 /init 脚本
init进程           第一个进程(举例如systemd),读取/etc/inittab配置,启动其他进程
   后续会运行dracut-cmdline等dracut子命令
   lsinitrd initramfs-5.10.0-136.12.0.86.h1428.aarch64.img |grep dracut-cmdline
切根               init完成初始化工作后,内核卸载initrd临时系统,切根到你平时常见/下面(无论是大伟博客还是宏涛给的journal.log都是先启动systemd,很后面才切根swicthRoot)


配置串口
// x86
console=tty0 console=ttyS0,115200
// arm
console=tty0 console=ttyAMA0,115200


重置root密码 
按e进入grub页面
启动参数删掉console=tty0 XXX;(奇怪,删掉串口输出为啥)添加rd.break=mount         
mount -o remount,rw /sysroot
chroot /sysroot
passwd -d root // 下面是备选方法?
   vim /etc/shadow 把root:XX: 前两个冒号之间的密码密文删掉,:wq   
   echo "root:XXX" |chpasswd
passwd root 
sync // 用于 强制将内存缓冲区中的数据写入磁盘
ctrlD ctrlD 正常进大系统


rd.break2 
我试过了rd.break不写默认效果是mount,草ds乱说的
我试过了rd.break不写默认效果是mount,草ds乱说的
// /sysroot下面空的
rd.break=pre-mount
// 可以认为/dev/mapper/rootfs已经挂载到/sysroot,它下面有内容
rd.break=mount
// 逻辑卷不识别的时候,/dev/mapper/只剩个control,其他卷设备是空的                激活逻辑卷->挂卷->切根
rd.break=initqueue



blkid2 
// 查询系统块设备的文件系统类型   以sda为例,常见叫法 磁盘设备 或者 分区
blkid /dev/sda
/dev/sda1 的本质：
   它只是块设备的标识符（类似于书的封面条形码），不代表文件内容本身。
   直接操作 /dev/sda1 相当于操作原始磁盘扇区，需要专业工具（如 dd 或 debugfs）。
挂载的作用：
   将设备中的文件系统映射到目录树（如 /mnt），操作系统才能理解文件结构。
   类比：必须把书翻开（挂载）才能阅读或修改内容，只看条形码（/dev/sda1）无法编辑。


capability2 
https://www.cnblogs.com/sparkdev/p/11417781.html
从内核 2.2 开始，Linux 将传统上与超级用户 root 关联的特权划分为不同的单元，称为 capabilites。Capabilites 作为线程(Linux 并不真正区分进程和线程)的属性存在，每个单元可以独立启用和禁用。如此一来，权限检查的过程就变成了：在执行特权操作时，如果进程的有效身份不是 root，就去检查是否具有该特权操作所对应的 capabilites，并以此决定是否可以进行该特权操作。比如要向进程发送信号(kill())，就得具有 capability CAP_KILL；如果设置系统时间，就得具有 capability CAP_SYS_TIME。


cat2 
// 什么都不写就是,你屏幕输入什么,打印什么
cat
// 当前屏幕在线写脚本,ctrl D 退出书写,这么玩不如vim,因为当前屏幕在线写没有退格,只能ctrl U,ctrl W 啥的来删除
cat > test.sh


cgroup2 
memory.usage_in_bytes 当前已用内存(曾经有一次echo 3 > /proc/sys/vm/drop_caches后,某cgroup的该值与top中某进程的res值接近)
// 已知pid,查看cgroup相关,如:查看memory的限制,它一般位于输出的第二行 memory:/system.slice/XXX/XXX/XXX
   需要拼接 /sys/fs/cgroup/memory/system.slice/XX
   需要拼接 /sys/fs/cgroup/memory/system.slice/XX
cat /proc/XXX/cgroup 


cpio2 
把文件/目录归档到XXX.cpio中或者从XXX.cpio中提取出来
// -o create archive 代表归档或者创建
   archive - Bing dictionary   US[ˈɑrˌkaɪv]UK[ˈɑː(r)kaɪv]
   n.档案；档案馆；档案室
   v.把…存档；把…归档；将（不常用信息）存档
ll /home/ | cpio -o > a.cpio
// -i --extract  Extract files from an archive,[ˈɑːrkaɪv] n 档案;档案馆;档案室;档案文件;
   -d 代表必要时自动创建目录,但我自己试过创建X.cpio并提取,似乎对源目录没啥子影响,也没什么打印,所以一时半会看不出cpio的意义是啥
cpio -id a.cpio
// 提取rpm包中文件,-v代表verbose
rpm2cpio X.rpm | cpio -idv


curl2 
curl is a tool for transferring data from or to a server using URLs
// -i 在输出中包含 HTTP 响应头（便于调试）
   -g 允许url可以包含{}[]
   -k --insecure不安全,大概就是跳过验证步骤
   -X GET	明确指定 HTTP 方法为 GET（默认即为 GET，可省略
   -H "accept: application/json"要求返回json格式
curl -igk -X GET https://XXX -H "accept: application/json"


chage2 
chage -l root // list account info
Last password change					: Nov 10, 2023
Password expires					: Feb 08, 2024
Password inactive					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 90
Number of days of warning before password expires	: 7


chown2 
chown root:root b.txt // 改变文件的所有者:所有者组
chown root a.txt //
chown :root c.txt //


date2 
date [option]..[+format]
// 什么是format,举例 %Y 四位年份 %m 月份 %d 日
date +%m_%d // 输出举例 01_17
   #!/bin/bash
   month_day=$(date +%m%d)
   status="status_${month_day}"
   smaps="smaps_${month_day}"
   #echo ${status}
   cat /proc/1/status > /home/${status}
   cat /proc/1/smaps > /home/${smaps}

// 根据str set时间,主机时间莫名其妙被改了,可以手动改回来
date -s "2024-04-17 10:18:50"
// display time described by STRING, not 'now',官方举例如下,1970至今秒数
date -d'@2147483647'
date --date='@2147483647'


/dev/null2 
/dev/zero2 
// linux 2个特殊的文件 
/dev/null  ： 在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。
/dev/zero  ： 在类UNIX 操作系统中, /dev/zero 是一个特殊的文件，当你读它的时候，它会提供无限的空字符(NULL, ASCII NUL, 0x00)。


dd2 
// /dev/zero  /dev/null 在上面
dd if=/dev/zero of=/mnt/test bs=1M count=10 oflag=direct
if      input file
of      output file
ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。
obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。
bs=bytes：同时设置读入/输出的块大小为bytes个字节。
iflag=direct 绕开fs的缓存
oflag=direct


df2 
df -h // disk free
df -i // 列出分区inode使用情况,inode被用光了也可能报错no space left
df -T // 打印fs类型

dhclient2 
// 动态获取ip,并显示详细过程
dhclient -v
// -x shutDown client
dhclient -x


dmesg2 
// -C 清除环回缓冲区
// -c 打印当前的缓冲区内容并清除,有次巡检不同过,就是把它备份后-c清空,难道巡检与dmesg有什么强相关?
dmesg -c

dmidecode2 
// -t 指定类型  0-bios 1-system 等等
dmidecode -t bios
dmidecode -t 1


dracut2
将为当前运行的内核版本生成一个新的initramfs映像文件，并将其保存在/boot目录下
// 不加force会提示不会覆盖已有镜像,加了后,镜像的modify,change会更新,
dracut --force
// 举例
1 /etc/lvm/lvm.conf,放开filter = XXX行 
2 dracut --forece命令重新打包
3 解压镜像(/usr/lib/dracut/skipcpio initramfs-5.10.0-182.0.0.95.h2545.eulerosv2r13.aarch64.img |zcat |cpio -id)再查看变化       解压镜像命令,前两段有点难懂


du2 
du -hs // diskUsage,默认显示当前目录,-s 总结      显示当前目录总大小
du -hs * // 显示当前目录,每个子项的大小


e2fsck2 
// check a Linux ext2/ext3/ext4 file system


echo2 
// echo --help是看不到帮助的,需要找出echo位置,如/usr/bin/echo --help       
// 默认末尾加换行,-n表示不要换行输出,-e解析反斜杠
echo -n "末尾不自动加换行,本str会直接输出在右侧"


/etc/fstab2 
磁盘被手动挂载之后都必须把挂载信息写入/etc/fstab这个文件中，否则下次开机启动时仍然需要重新挂载。 系统开机时会主动读取/etc/fstab这个文件中的内容，
根据文件里面的配置挂载磁盘。这样我们只需要将磁盘的挂载信息写入这个文件中我们就不需要每次开机启动之后手动进行挂载了
fs_freq参数决定了文件系统是否需要进行备份。具体来说，如果这个参数设置为0，表示该文件系统不需要执行dump操作，即不需要进行备份；如果设置为其他值，则表示该文件系统需要定期执行dump备份。
fs_passno参数则用于指定系统重启时文件系统的检查顺序。通常，fs_passno为1的文件系统会在其他文件系统之前被检查，这通常是指root文件系统；而fs_passno为2的文件系统会在所有fs_passno为1的文件系统之后进行检查。
   fsck程序会按照fs_passno的顺序来检测磁盘，即先检查fs_passno为1的文件系统，然后是fs_passno为2的文件系统，以此类推。0值的fs_passno意味着该文件系统不被fsck检查。
/dev/cpsVG/rootfs / ext4 acl,dioread_lock,data_err=abort,nospeed,defaults,iversion 1 1
/dev/md2 /boot ext4 defaults,iversion,nodev,dioread_lock,data_err=abort,nospeed 1 2


/etc/profile2 
全局配置文件,用户登录时会自动执行它


/etc/profile.d/ 
包含系统级别脚本,用户登录时被执行


个人配置文件      ~/.bashrc           敲alias展示结果来源于此
`~/.bashrc` 是 Bash shell 的配置文件，它包含了一些用户自定义的环境变量、别名、函数和命令等。当用户登录到一个 Bash shell 时，Bash 会自动执行 `~/.bashrc` 文件中的命令，
以设置用户的环境变量和自定义命令等。这个文件通常用于设置用户的个性化环境，比如设置命令别名、添加 PATH 环境变量、定义 shell 函数等。
rc 代表run command,类似的还有~/.vimrc 我喜欢默认加上:set nu hls cursorline cursorcolumn
注意             改完记得source file // source命令 "从file中读取并执行命令"


&&  第一个命令退出码0才执行第二个命令,以此类推
确认I层内存总体使用量，命令：cd /sys/fs/cgroup/memory/system.slice/fsp && cat memory.usage_in_bytes && cat memory.limit_in_bytes


/etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin // 7列
logName:密码全部用X代替:uid:gid:userName:homeDir:用户登陆后默认的shell程序
真实密码在/etc/shadow中,加密串,不是明文,好像也没啥卵用
/sbin/nologin 或者 /bin/false 代表禁止此用户默认登录

/etc/sysconfig/network-scripts/ifcfg-eth0 // 默认网卡配置文件 <linux系统命令及shell脚本实践指南> 6章 网络管理
如果网口不在这个目录里面,说明网口不受network管理,由上层业务下发管理


ethtool2 eth2 
// -i interface 显示网口eth0的驱动信息
ethtool -i eth0
// -P permanent Addr ,也称 hardware Addr,也称 MAC
ethtool -P eth0 
up               L3网络层      管理员手动控制,独立于物理状态,如ifconfig up/down属于3层
link detected:no L2数据链路层    由硬件/驱动直接检测
NO-CARRIED         L1物理层      但是因为物理层的原因导致网络没连接，比如网线没插好之类的


// export命令声明了将由子进程所继承的一个或多个变量。这些变量被导出后，当前shell脚本所执行的任何应用程序都会获得这个变量。
// 在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。
linux配置path,全用户有效,举例:配置rust的path
vim /etc/profile
export PATH="$PATH:~/.cargo/bin"
export -p //列出当前的环境变量值
source /etc/profile


faillock2 
// 重置用户登录失败次数
faillock --user=root --reset


fdisk2 
manipulate disk partition table
fdisk /dev/sda
   n 新建一个新分区
   p (新建主分区)
   1 (使用第1个主分区)
   两次回车(使用默认配置)
   wq (保存分区表)


find2 
// -type d 只查找目录 
   2>/dev/null 标准错误流向"无底洞",也就是丢弃错误信息
find / -name uvp-getosstat -type d 2>/dev/null  
// find 会直接打印当前目录所有,下面更简短更强
find |grep log
find . -name log*
// -xdev 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件,举例,假设/目录是ext4,u盘文件系统是iso9660,从/搜索rpm就搜不到u盘里的rpm
find / -xdev -name \*.rpm
// %p 代表fileName(注意英文的file==中文文件+目录),假设/home下面有个dir0,里面只有个a.txt,那么下面输出两行,一行是/home/dir0,一行是/home/dir0/a.txt
find /home/dir0 -printf '%p\n'
// %h 代表dirname且去掉了末尾的fileName(linux manual,理解了%p就能理解这个),下面命令分两行完成!!!大致意思:遍历/home下每个文件,但是呢,只打印目录+换行           "哪个目录inode占用多"
   每个文件或者目录都会占用一个inode条目
find /home -printf '%h\n' | uniq -c |sort -k 1 -n
// -type f 搜索regularFile   
   %s 文件bytes大小
   %p 代表fileName(注意英文的file==中文文件+目录)
   -n numeric(按数字大小默认升序) 
   -k 1 指定第一列排序                                  "最大文件",find命令无法搜索到lsof中deleted大文件,find机制:遍历目录树举例/,检查每个目录项dentry,而deleted文件没有dentry,补充dentry知识点?
find /var/log -type f -printf '%s %p\n' |sort -n -k 1


free2 
free -m

fuser2      
Show which processes use the named files, sockets, or filesystems.
// -m show all processes using the named filesystems or block device
   -v verbose
fuser -mv /var/log



fsck2 
通常修分区4步
// umount第一条,不能在当前目录结构当前目录
umount mountPoint
// -n 以只读模式运行`fsck`，即不对文件系统进行任何实际的修复操作 -f 表示强制运行`fsck`，即使文件系统被标记为“干净”（clean），也会进行检查和修复
fsck -nf /dev/sda 
fsck -y /dev/sda
mount /dev/sda mountPoint


grep2 
背景 大概找一下下面这个宏是哪些补丁用到了,假设有(对比开源版本的商用的版本的补丁),看是不是漏打补丁了
#ifndef OPENSSL_FIPS         // ndef==not defined 这个宏没有定义
# error FIPS is disabled.
#endif
// -r递归目录(grep最后可以接单个文件,多个文件,或者目录配合-r) -n显示行号 -w单词匹配 -v反转查找
   当前目录下有很多补丁,从补丁从查找谁用到openssl_fips这个宏,并且把ifdef给排除掉,最后一个grep仅仅是为了颜色高亮,因为第二个grep -v会把高亮抹掉
   r 递归目录 
   n行号 
   w单词匹配  
   E拓展表达式 v取反
   -A3     // 多展示后面3行
   -B3     // 多展示前面3行
   -C3     // 多展示后面前后各3行
grep -rnw OPENSSL_FIPS ./ | grep -v ifdef | grep OPENSSL_FIPS        
// -m 最大匹配行数
ps -aux |grep -m 2 'root'


grub2 
无故进入grub模式,屏幕显示grub>
// hd0,1,2 gpt1,2,3    如果你发现下面展示和正常的节点/boot内容相同
ls (hd1,gpt2)/
// 手动引导
set root=hd1,gtp2
linux /vmlinuz-XX root=/dev/cpsVG/rootfs console=tty0
initrd /initramfs-XX.img
boot
grub2-mkconfig -o /boot/efi/EFI/euleros/grub.cfg，重新生成grub.cfg文件。生成成功后reboot，OS恢复正常


hwlock2 
// rtc硬件时钟==hwlock -r       systemtime==date  
// -r display rtc
// -w 虽然w不是write的意思,通常叫法是"写硬件时钟"   用什么写呢,当然是systemtime    set rtc from system time
// -s 反过来  set system time from rtc
hwclock -w


ifconfig2 
// -a 展示所有network interface,不加只展示激活的interface
ifconfig -a
ifconfig eth0 up


iostat2 
// -d 显示disk统计信息,默认disk和avg-cpu都会显示,所以这  -d -c没卵用,不如不加
   -c display cpu utilization实际展示avg-cpu
   -m 单位 MB
   -k 单位 KB
   -t     Print the time for each report displayed 每小段统计数据上方有一行时间戳
   -x display extended statistics
    1 每隔1s刷新一次
    5 共刷新5次
iostat -mtx 1 5 /dev/sda /dev/sdb
iostat -mtx 1 // 每1秒刷新一次,一直刷
字段:
rrqm/s：   每秒有多少个"取件请求"被你合并处理了（比如把同一栋楼的5个取件合并成1趟）
wrqm/s：   每秒有多少个"寄件请求"被你合并处理了（比如把寄往同一城市的3个包裹合并成1个包裹）
rKB/s    读带宽
avgrq-sz   和/sys/block/sdb/queue/max_sector_kb有关联        https://bean-li.github.io/dive-into-iostat/
avgqu-sz   待处理io队列大小,平均值,值越大,"排队的人越多"


ip a 
ip是个很强的命令,有很多子命令如 ip addr      ip link      ip route 等
ip a show eth0
10: eth0: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1800 qdisc mq master trunk2 state UP group default qlen 1000
    link/ether a4:6d:a4:90:3d:5e brd ff:ff:ff:ff:ff:ff  // 该接口的MAC地址
    inet6 fe80::d84d:36ff:fec4:936/64 scope link        // ipv6
       valid_lft forever preferred_lft forever
10          编号10,从1开始没啥好说的
UP          表明eth0被启动,逻辑上 // 例如有次pxe报错dhclient enpXXX failure,ip a show显示这个enpXXX网卡呢没有up,lower_up,只能通过ethtool查看这个网卡的2层链路状态
LOWER_UP    表明eth0物理链路上已连接
mtu==max trans unit最大传输单元   单位是字节
qlen 1000    接收队列的长度为1000
brd ff:ff:ff:ff:ff:ff   广播地址

ip a s // 感觉这两个命令用来查询网卡信息,没区别呀...


// 将物理网卡 eth5 的第 4 个虚拟网卡的带宽限制为 1000 Mbps
ip link set eth5 vf 4 rate 1000
ip link set eth4 down/up
// 网络接口前面加个dev似乎没缺点
ip link set dev eth6 vf 9 mac 00:11:22:33:44:55



// 展示所有网口信息  这个命令会显示vf配置在xml中的mac地址,ip a不行
ip link show |grep XXX 
ip link show eth9


iptables2 ip6tables 
// -v verbose
   -n numeric
   -L 列出[chain [rulenum]]
   --line-numbers   显示行号,删除rule的时候用得到行号
iptables -vnL
// -D 删除chain [rulenum]   删除名为input的chain中第二条rule
iptables -D INPUT 2
// 保存在/etc/sysconfig/iptables中
service iptables save
// -A INPUT 给input规则append
   -p tcp 指定协议是tcp
   --dport   指定des端端口8002
   -s        指定src端地址
   -j         指定动作ACCEPT DROP REJECT 等
ip6tables -A INPUT -p tcp --dport 8002 -s 2409:8080:5A0A:6058::/80 -j ACCEPT 
// 删除所有rule
   -F Flush the selected chain (all the chains in the table if none is given).  This is equivalent to deleting all the rules one by one.
iptables-save > /home/XX.txt
iptables -F
iptables-save < /home/XX.txt


irqbalance2 
/etc/sysconfig/irqbalance
IRQBALANCE_BANNED_CPUS=ffffffff,fffffffc,ffffffff,fffffffc
f 代表(先转成2进制,全是1)不参与中断   一位16进制==4位二进制,上面32位16进制==128位2进制,刚好当前环境上cpu是128核
0 代表参与中断
irqbalance意义:每个核上均匀参与中断处理,使性能更佳


iscsiadm2 
    iscsi target：存储设备端，服务器端的设备，为其他服务器提供“磁盘”。
    Iscsi initiator：使用target提供“磁盘”的客户端。
// 查询当前主机登入的存储设备
iscsiadm -m session
// 查看当前主机上发现所有target
iscsiadm -m node
// 发现阵列ip==对端业务ip的目标
iscsiadm -m discovery -t st -p ip:port
// -T targetName


jobs bg fg & ctrl+Z 后台
// 假设很耗时,ctrl+Z暂停此任务
tar -zcf usr.gz /usr 
// 展示任务,不出意外上述任务编号为1
jobs
// 后台运行任务1号,fg类似
bg 1
// 或者一开始指定后台运行 &
tar -zcf usr.gz /usr &


journalctl2 
一个用于查询和显示由systemd日志管理系统（systemd-journald服务）收集的日志信息的工具
// -u 参数指定了要查看的服务的名称，例如 `journalctl -u ssh
journalctl -u sshd	
// -f follow the journal 展示最新日志 journal杂志,日志  entry[n]记录,词条 journey[n v]旅游
   应用场景:cps host-list显示虚拟机fault,查看journalctl日志发现rootfs没挂上去?或者fsck失败?手动fsck
   挂iso启动,dmesg和journalctl只针对当前镜像启动,没什么参考价值
journalctl -f -u sshd 


killall2 
// -w Wait for all killed processes to die
// 实操加不加前置路径都可以
killall -w /sbin/dhclient


ldconfig2 
ldconfig 命令用于在默认搜寻目录 /lib 和 /usr/lib 以及动态库配置文件 /etc/ld.so.conf 内所列的目录下，搜索出可共享的动态链接库（格式如 lib*.so*），进而创建出动态链接器（ld.so 或 ld-linux.so）所需的缓存文件。缓存文件默认为 /etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表。为了让动态链接库为系统所共享，需运行动态链接库的管理命令 ldconfig 更新动态链接库的缓存文件。
附
/proc/sys/vm/drop_caches 是一个系统文件，它允许用户在 Linux 操作系统中清除内核缓存。这个文件包含一个整数，它控制哪些缓存应该被清除。具体来说，这个整数的值可以是以下之一：
- 0：什么都不清除(默认)
- 1：清除页缓存。
- 2：清除目录项和inode缓存。  dentries and inodes   如何理解dentries??
- 3：同时清除页缓存、目录项和inode缓存。
---
echo 3>/proc/sys/vm/drop_caches
rm -f /etc/ld.so.cache
ldconfig
---


ldd2 
print shared object dependencies 列出某程序所需动态链接库(.so)
// 切根后panic,串口回忆如下               
   failed start kenel modules
   system-load.service??
   starting switch root
   kernel panic
   断点pre-mount
mount /dev/mapper/rootfs /sysroot
chroot /sysroot
ldd /usr/lib/systemd/systemd                                                                举例,输出提示/usr/lib/systemd/libsystemd-shared-XX.so=>not found
没有共享库文件->从正常环境拷贝一份
 有且md5sum变化   从正常环境拷贝
 有且md5sum不变   ldconfig刷新


ln2 
// ln -s target link_name


lvm2 
lvm.conf  filter
// This is a list of regular expressions used to accept or reject block device path names
   LVM就只会扫描并管理/dev/sda和/dev/sdb这两个设备，其他设备会被过滤掉
filter = [ "a|^/dev/sda$|", "a|^/dev/sdb$|" ]
// Reject the cdrom drive:
filter = [ "r|/dev/cdrom|" ]
// vgchange代表改变vg属性 -a代表active -y代表yes                                      在系统中激活所有已知的卷组
   系统启动时，bios会扫描所有盘找到系统启动的引导文件。也就是boot分区(只有系统盘中才会有boot分区)，及分区内的grub.cfg，引导文件initrd等。引导入内存后根据lvm.conf2的过滤条件激活逻辑卷，然后挂载启动
lvm vgchange -ay 


lsblk2
// -f 输出fs类型
lsblk -f
NAME                   MAJ:MIN  RM  SIZE RO TYPE MOUNTPOINT
sda                      8:0     0  3.5T  0 disk
├─sda1                   8:1     0  500M  0 part /boot/efi
├─sda2                   8:2     0  500M  0 part /boot
└─sda3                   8:3     0  3.5T  0 part
  ├─rootfs             253:0     0   11G  0 lvm  /
注意看/boot/efi  /boot  / 分别在sda123  -> 由 UEFI 规范、引导流程需求和分区管理最佳实践 共同决定的



lscpu2
有时候不同节点的cpu的flag不同,也有称为cpu feature的,而这些cpu flag从硬件获取的,大概率是bios设置相关,举例bios开关MonitorMwaitEnable,开了flag里面就有monitor这个值,没开就没有


lsof2
// list open file
// 如 df -h某分区占满,du -hs --max-depth=99 /home 下面没几个大文件or目录,就极有可能是进程占用句柄没有释放
lsof |grep delete |grep home
lsof -i:22 // -i 选项有点长 [46][proto][@host|addr][:svc_list|port_list] 
lsof -i:4TCP:22 // 查看ipv4,tcp协议,端口22相关的打开的文件
lsof -p 10086 // 查询指定进程打开的文件
lsof |grep 10080 // 这种是全量查询再过滤pid,输出可能包含tid=XXX或者为空的行,去掉tid为空的行的统计结果才是进程打开的文件行
// -t 仅输出pid,通常与kill配合使用,https://www.man7.org/linux/man-pages/man8/lsof.8.html
lsof -t /var/log 


lspci2 
lspci |grep -i eth // 系统从硬件识别上来的pci设备,过滤出网卡,这出问题就是系统问题
ll /sys/class/net // 驱动把pci设备识别成网卡,这出问题就是驱动问题
// -s 指定domain bus device func号
   -v verbose   
lspci -svvv 0000:00:03.0
lspci -svvv 00:03.0
// -t show bus tree 有次他问两套环境配置一样,但pci不同,直接正常/异常敲命令并对比,发现差异pci号了,网卡位置插得对不对?                    pci号是硬件决定的，系统这边只是取一下，不做分配
lspci -tv 


lvresize2 resize2fs2 
// -L 调整大小,
lvresize2 -L+9G /dev/mapper/rootfs
lvresize2 -L-9M /dev/mapper/rootfs
resize2fs /dev/mapper/rootfs


md5sum2 
// 某目录下有多个文件,可以用*指定多个文件
md5sum *
//
md5sum XXX.txt


mknod2 
// -m 指定权限 c 字符设备 13分别是主次设备号(为啥13不懂)
mknod -m 666 /dev/null c 1 3 


mkfs2 
// 在设备sda上创建文件系统==格式化分区
mkfs /dev/sda
// 在设备sdb上创建ext4类型文件系统
mkfs.ext4 /dev/sdb


mount2 
// -o 后面接逗号分割options,remount选项代表重新挂,rw选下来代表读写,例如原先只读的系统，现在以可读写的模式重新挂上
   mount device|dir -o options  官网:写设备和写挂载点都可以
mount -o remount,rw /dev/mapper/cpsVG-image
// -B --bind 把一个目录"镜像"到另一个位置，就像给文件夹创建了一个"分身"或"快捷方式+"。
   -R, --rbind             mount a subtree and all submounts somewhere else
mount --rbind /proc proc/
// 当使用 -o loop 选项时，mount 命令会自动找到一个可用的回环设备（如 /dev/loop0）。这个回环设备会将 XXX.iso 文件虚拟化为一个块设备。
   实测,加不加loop,我看.iso挂完后lsblk,type列都是loop
mount -o loop XX.iso /mnt/iso


mpstat2
mpstat [-P {|ALL}] [internal [count]]
// -P {|ALL} 表示监控哪个CPU， cpu在[0,cpu个数-1]中取值
   internal 相邻的两次采样的间隔时间、
   count 采样的次数，count只能和delay一起使用
   监视cpu8,9,10,11的数据 间隔1秒 采样2次 输出3段内容,最后一段是前2段采样的平均值
mpstat -P 8,9,10,11 1 2 
mpstat -P 0-13 2 5


netstat2 
打印网络连接、路由表、连接的数据统计、伪装连接以及广播域成员
   Local Address   本地地址和端口
   Foreign Address 远程地址和端口
   state       常见 established listen(首先服务端需要打开一个socket进行监听，状态为LISTEN./*The socket is listening for incoming connections. 侦听来自远方TCP端口的连接请求)
   -a   display all sockets
   -t   tcp协议
   -u   udp协议
   -n   numeric
   -l   display listening server sockets
   -p   display pid/program name for socket 常常lp一块使用
netstat -anlp |grep ssh


nslookup2 
nslookup network.XX.com
Server:		172.28.8.21      dnsServer的地址
Address:	172.28.8.21#53
Name:	network.XX.com         这个域名指向下面的地址
Address: 128.9.61.10


ntp2 
network time protocol
// 列出时钟源
ntpq -p 


ntpdate2 
set the date and time via NTP
// -d debugMode 后面是ntpServer的ipv6
ntpdate -d fc00:ac1c::b2a 

ntpq2 
ntpq -p // 列出时钟源


osi七层    简化4层
应用层 定义客户端与服务端数据交换方式 如http ftp
传输层 定义数据传输方法,主要两种协议 tcp udp 举例http的数据包不允许丢失,因此采用tcp来传输
网络层 使用ip定位目标计算机,采用route决定数据传输路径
链路层 可能是eth,光前fiber,无线网


pageUp2
// 众所周知,上下键可以切换历史命令,
// 举例:当你敲了ssh 然后pageUp时候,只会展示之前ssh相关的历史命令,好用!!!


passwd2 
// -d delete the password for the named account (root only)
   -S status
   -l lock
   -u unlock
passwd -S testuser
passwd -d root
testuser P 05/15/2024 0 99999 7 -1
各字段详细解释
1	testuser	用户名
2	P	密码状态：
   P：已设置密码（有效）
   L：密码被锁定
   NP：无密码
3	05/15/2024	最后修改密码的日期（MM/DD/YYYY格式）
4	0	密码最小使用天数（修改后必须经过的天数才能再次修改）
5	99999	密码最大有效期（天数，99999表示永不过期）
6	7	密码过期前警告天数（到期前多少天开始提醒用户）
7	-1	密码过期后宽限天数（-1表示禁用宽限期，过期立即失效）


perf2
// -g 记录调用栈
// -C 0 指定cpu0
perf top -g -C 0
// 输出结果里idle可以忽略跳过,主要关注快慢节点上的区别 do_syscall,exc_page_fault
do_syscall代表用户态切到内核执行系统调用,所以这个也是上层排查
exc_page_fault跟内存分配强相关,慢环境上内存剩余约4g,快环境上内存剩余约15G,慢环境上大页占据约9G



pgrep2
pgrep ssh // 只展示ssh进程的pid
pgrep -l ssh // -l 展示 pid 和 processName


pkill2
// 通过进程名字杀进程  -f 代表full process name 
pkill -9 -f /usr/XXX.py


printf2 
// printf formatStr args
printf "first %s %s\n" hello world
printf ":set nu hls cursorline" >> ~/.vimrc


// 保存的是bootloader(引导加载程序) 启动linux kernel 时的参数
/proc/cmdline
/proc/meminfo |grep -i huge*


/proc/mounts
cat /proc/mounts |grep root
rootfs / rootfs rw 0 0
/dev/mapper/cpsVG-rootfs / ext4 rw,relatime,i_version,stripe=64,data=ordered,data_err=abort 0 0
fileSys 挂载点 fs类型如ext4 挂载选项 dump备份表示(0不备份,1备份) pass(FS检查顺序,0不检查,1第一个检查,n第n个检查)


trunk2 
/proc/net/bonding/trunkXXX
speed   1000Mbps // 网卡最大带宽?小b换算大B要除8
举例两个网口组成trunk0,可以通过mac找到trunk的网口,比如eth9以前的mac是后面permaddr,组trunk后mac统一变成前面的值,
10: eth8: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc mq master trunk0 state UP group default qlen 1000
    link/ether ac:dc:ca:7e:a1:e2 brd ff:ff:ff:ff:ff:ff
11: eth9: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc mq master trunk0 state UP group default qlen 1000
    link/ether ac:dc:ca:7e:a1:e2 brd ff:ff:ff:ff:ff:ff permaddr ac:dc:ca:7e:a1:e3
254: trunk0: <BROADCAST,MULTICAST,MASTER,UP,LOWER_UP> mtu 1500 qdisc noqueue master ovs-system state UP group default qlen 1000
    link/ether ac:dc:ca:7e:a1:e2 brd ff:ff:ff:ff:ff:ff
    inet6 fe80::aedc:caff:fe7e:a1e2/64 scope link


/proc/pidXXX/fs // ls /proc/pidXXX/fd |wc -l 这种也能统计进程打开的文件数


/proc/pidXXX/oom_score   // 只读,系统计算出来
/proc/pidXXX/oom_adj    // 老参数,作用是兼容
/proc/pidXXX/oom_score_adj // 
Linux下面有个特性叫OOM killer（Out Of Memory killer），这个东西会在系统内存耗尽的情况下跳出来，选择性的干掉一些进程以求释放一些内存。具体的记录日志是在/var/log/messages中，如果出现了Out of memory字样，说明系统曾经出现过OOM
oom_score_adj，用来控制进程打分，分数越高，就先杀谁。oom_score_adj取值范围是-1000到1000，默认值为0。oom_score_adj设为-1000时，表示禁止OOM killer杀死该进程


ps2
// 查看所有帮助
ps --help a
ps -aux | head -1;ps -aux |grep 889 // 利用head -n ? 显示?行
ps -aux |grep -E "^USER | 889" // 利用正则顺便把USER开头的首行查找出来,但有个缺点如下
ps -ef |grep -E "^UID | 889" // ps 后接不同的选项首行的内容也不相同
// -e Select all processes.  Identical to -A
   -L Show threads, possibly with LWP and NLWP columns
   -o  指定格式,后面单词(官网称之为format specifiers)不能写错
   psr 代表processor that process last executed on  进程运行的CPU编号?翻译不够准确?
   comm 代表command
ps -eLo pid,psr,comm | awk '{if ($2 >= 1 && $2 <= 1) print}'                              // 查出cpu1上跑的进程
// --sort=-rss -rss代表rss数字升序,不写或者写+默认数字升序
ps -aux --sort=-rss |head -9


pushd popd dirs 目录栈
// 往目录栈top压入 /home 并切到此目录
pushd /home
// 往目录栈top压入 /tmp 并切到此目录
pushd /tmp
dirs // 展示目录栈 /tmp /home
// 不指定参数，则会回到前一个目录，类似cd - ,并把目录栈top的两个目录作交换
pushd 
dirs // 展示目录栈 /home /tmp
// 弹出/home,那不就是切到/tmp
popd


realpath2 
realpath 某文件 // 显示文件路径


reboot2   主机反复重启定位
原因多样,这里举例np卡引起的定位方法
mv /usr/sbin/reboot /usr/sbin/reboot.bak
echo '#!/bin/bash' > /usr/sbin/reboot
echo 'ps -ef >> /root/ps.log' >> /usr/sbin/reboot
chmod 777 /usr/sbin/reboot

mv /usr/sbin/shutdown /usr/sbin/shutdown.bak

rm2
rm -r dir0 dir1


route2 
A网络中设备想连B网络中设备,需要借助连接两个网络的某特殊设备发送packet,这个特殊设备叫网关 <shell脚本攻略 6章>
路由表包含了packet如何转发的信息
// -A inet6 指定地址族,不写相当于只展示ipv4的
   -n numeric,
route -A inet6 -n


rpm2 
rpm -qa // 查询所有包
find /lib64/ -name "librdmacm.so.1" // 例如输出/lib64/librdmacm.so.1
// --changelog 比如你给某个rpm包合入过代码,那么就能用changelog查询到
rpm -qi XXX.rpm --changelog |less 
// -f 查询哪些包"拥有"此文件
rpm -qf /lib64/librdmacm.so.1
// -l 列出指定软件包的所有文件路径，包括配置文件、二进制文件、库文件等(包名不需要打全,打一部分也可以)
rpm -ql openssh-client-XXX
// 查询XXX所需依赖
rpm -qR XXX
// --nodeps 已有安装1250的包,已上传1260的包,rpm -Uvh 1260的时候总是提示fail dependencies,解决:--nodeps
rpm -Uvh 1260 --nodeps
// --forece 常见于XXX already install,重新强制安装
rpm -ivh XXX.rpm --force


rpm2cpio2 
// 提取rpm包中文件,-v代表verbose
rpm2cpio XXX.rpm | cpio -idv


rsync2
// -r 递归 dir1下面有个a.txt 
rsync -r /home/dir1/ /home/dir2/
// -a 参数可以替代-r，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等） -a archive mode
       The files are transferred in archive mode,
       which ensures that symbolic links, devices, attributes,
       permissions, ownerships, etc. are preserved in the transfer
// -v 代表verbose 至于后面的 用户@ip:目录 类似scp -z代表压缩(网络传输时改善传输效率)
rsync -avz /home/data root@172.X.X.X:/home/back/data


scp2 
// ipv4 当时从已登录的单板9.11...上传了证书(被改名为github.cer)到自己的单板9.13...上
   -r 递归整个目录 
scp -P 端口 github.cer 多文件空格分隔 9.13.7.128:/etc/pki/ca-trust/source/anchors/	
scp -P 端口 -r /home/ 9.13.7.128:/home/	
scp github.cer 多文件空格分隔 [2003:0:d05:225::26]:/etc/pki/ca-trust/source/anchors/	                        注意ip与目录之间别漏了 冒号 ::::::::::
// 只要本机能ping通198,就能从198上远程拷贝日志到本机当前目录
scp hyj@198.91.130.161:/home/hyj/a.log ./
// scp对Strict有严格顺序要求
scp -r -o StrictHostKeyChecking=no /boot/efi/*  172.0.0.1:/boot/efi


sh2 
// -c 把后面字符串当命令执行 https://blog.csdn.net/weixin_53389944/article/details/136560945
sh -c 'XXX'
// -x 进入跟踪方式，显示所执行的每一条命令
sh -x a.sh > /home/t.txt // 我发现文本没内容
sh -x a.sh 2>&1 > /home/t.txt
sh -x a.sh > /home/t.txt 2>&1
sh -x a.sh &> /home/t.txt // &在这不是后台运行命令,注意 &> 要相连,&>：是 > 和 2>&1 的组合写法，表示 同时重定向 stdout（标准输出）和 stderr（标准错误）



size2 
size命令用于查看目标文件、库或可执行文件中各段及其总和的大小，是 GNU 二进制工具集 GNU Binutils 的一员。
size hello.o
[root@localhost test]# size hello.o
   text	   data	    bss	    dec	    hex	filename
    115	     80	      0	    195	     c3	hello.o


sleep2 
// s m h d,秒分时天,不写默认单位秒
sleep 2d


soft lockup 软锁  hard lockup 硬锁  触发panic机制
软锁 cpu被内核代码占据
硬锁 cpu被内核代码占据,且不响应中断

sort2 
// 通常配合uniq去重统计使用,-c统计个数,作为结果第一列
sort | uniq -c
// -t 指定字段分隔符 
   -k 指定第三列排序(字典序?短,小,升序,平时使用总是按数字排序,所以-n少不了的) 
   -n 按数字默认升序
   -r 降序
sort -t ':' -k 3 -n /etc/passwd


source2
它会将脚本中的命令直接加载到当前 Shell 中执行,而不是新的子shell
sh2区别
sh 命令用于启动一个新的子 Shell 来执行脚本文件


string2
从二进制中提取字符串的工具
string /usr/lib64/libc.so.6 |grep GLIBC    最高支持2.38??


return2
return: can only `return' from a function or sourced script,退出当前函数,不是退出整个脚本,return和break什么区别不用重复了吧
exit2
终止shell脚本执行,可以在脚本任何地方使用


ssh-keygen2 
// -C 为密钥添加注释,通常用于标识密钥的用途或所有者
// -t 指定密钥类型,可选值为dsa、ecdsa、ed25519、rsa,默认为rsa   所以-t rsa没必要加了
// 然后把id_rsa.pub的内容加到github中就行了
ssh-keygen -C XXX@163.com


ssh2 sshd_config2 
ssh_config主要关注客户端如何连接到SSH服务器，‌
sshd_config则关注SSH服务器如何配置以响应这些连接请求
sshd_config中的ListenAddress 指定 SSH 服务器监听的 IP 地址
假设服务器有2个网卡,一个连内网(假设ip 192.168.1.11),一个连外网(假设ip 192.168.1.22),如果只监听内网网卡ip的话,可以减少外部攻击的风险
// 可以观察到ssh监控的ip
netstat -tunlp |grep ssh
// 经典问题,假设listenAddress监听两个ip,上面命令只查出来一个
首先systemctl status sshd 确认sshd服务拉起时间
message日志bind to port 22 on XX failed: cannot assign requested address
sysmonitor日志eth4: ip[172.28.0.4] prefixlen[20] is added,
正确时序:先ip被添加,sshd服务拉起后才会根据listenAddress去监听ip
为啥绑定报错->因为ip不存在->为啥不存在->dhcp还没获取到这个ip地址
// 实测AllowUsers不添加root,root没法登陆
PermitRootLogin yes
AllowUsers XX root


stat2 
输出中modify与change的区别
modify`时间戳表示文件的内容最后一次被修改的时间，即文件内容的修改时间。
change`时间戳表示文件的元数据最后一次被修改的时间，即文件权限、所有权、链接等元数据的修改时间
size 4096 linux中目录的size通常为4096,或者4096倍数?


strace2
// -t           在输出中的每一行前加上时间信息。
   -tt          在输出中的每一行前加上时间信息,微秒级。
   -ttt         微秒级输出,以秒了表示时间。
strace -o /home/fsp/hyj.txt  -tt rpm -evh XX.rpm


su2 
// 不写用户,默认切root,环境变量还是当前用户的
su 
// 不写用户,默认切root,环境变量是root 用户的   https://www.cnblogs.com/linyfeng/p/13511945.html
su -


sudo2 
// sudo诞生前,su的缺点是要输入root密码,sudo使一般用户不需要知道超级用户的密码即可获得权限。首先超级用户将普通用户的名字、可以执行的特定命令、按照哪种用户或用户组的身份执行等信息，登记在特殊的文件中（通常是/etc/sudoers


/sys/fs/cgroup/cpuset/cgroup.procs                                    决定哪些进程只能使用指定的 CPU 核心，就像给进程分配固定的“工作座位”。
// 把当前shellPid写入它里面,允许当前shell使用cpu
echo $$ >> /sys/fs/cgroup/cpuset/cgroup.procs
CPU 核心 = 办公桌（比如 4 张桌子对应 4 个 CPU 核心）
cpuset = 你给不同项目组划分的专属办公区（比如：A 组只能用 1-2 号桌，B 组用 3-4 号桌）
cgroup.procs = 贴在办公区门口的成员名单，只有名单上的人才能进这个区域工作
/sys 是内存虚拟文件系统
   /sys/fs/cgroup/ 下的文件仅存在于内存中，由内核动态生成
   所有修改不会写入磁盘，重启后内核会按默认配置重建
进程生命周期绑定
   echo $$ 操作仅对当前Shell进程有效
   若Shell退出（如关闭终端），进程自动移出该cgroup
   子进程不会继承这一设置（除非显式配置）
cgroup 的临时性设计
   默认cgroup规则是会话级（session）的临时控制
   持久化需要借助管理工具（如systemd、cgconfig）


sysctl2 
// 显示所有系统参数,NMI中断采样频率降低,说明主机性能差,NMI处理时间变长,系统会自动降低此频率
sysctl -a |grep perf_event_max_sample_rate 
sysctl -a |grep panic |grep oom
// 关闭oom时panic
sysctl -w vm.panic_on_oom = 0


/sysroot2 
最终系统根目录 (/)	毛坯房（未来要住的房子）
/sysroot	临时工棚（存放装修工具和材料）
PXE启动时：
   你的电脑像一块空地，通过网络加载临时系统（工棚）。
   这个临时系统把真正的系统安装包（瓷砖、油漆）放到 /sysroot 里准备装修。
安装过程中：
   安装程序把 /sysroot 里的文件"装修"到目标磁盘（毛坯房）。
   完成后，/sysroot 会被卸载，最终系统从磁盘上的 / 启动。


systemctl2 
systemctl status hkids
○ hkids.service - hkids deamon server
     Loaded: loaded (/usr/lib/systemd/system/hkids.service; enabled; vendor preset: disabled)
// 上面enabled代表hkids服务开机自启
systemctl enable hkids



tar2 
// 压缩某个目录
   -z 压缩,解压 XXX.tar.gz的话,一般加个它
tar -cvf XXX.tar /home/*
tar -zcvf XXX.tar.gz /home/*
// 压缩多个文件
tar -cvf XXX.tar /home/a.txt /home/b.txt
// -C 解压到目标目录下
tar -zxvf  XXX.gz  -C  ./


tail2 
tail -f message |grep sshd
cat XX.txt |tail -9


tcpdump2 
格式:tcpdump option protocol diretion type                              https://www.cnblogs.com/wongbingming/p/13212306.html
// -v verbose -v -vv -vvv
   -nn 单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。这样不仅方便查看 IP 和端口号，而且在抓取大量数据时非常高效，因为域名解析会降低抓取速度。
   -e  显示数据链路层信息。默认情况下 tcpdump 不会显示数据链路层信息，使用 -e 选项可以显示源和目的 MAC 地址，以及 VLAN tag 信息
   -i 指定interface, -i any就是指定所有网口(物理网卡可能有多个网口,例如eth2)
   -w 指定输出文件
   [src/dst] host 192.XX 感觉host+ip固定写法吧,host不关心src/dst之类的
tcpdump -vvv -i any host 192.168.0.1 and port 443 -w /home/a.pcap  
tcpdump -i trunk0 -nne 
tcpdump -vvv -i enp129s0f0 -w XXX.pcap
// 源端ssh连不上目的,|info|sshd[2054272]|Connection from fc51:158:46:17::32 port 58890 on fc00:0:0:2621::2 port 22 rdomain ""
   1 先确定目的端ip对应的网口名字叫external_api,然后目的端敲命令如下
tcpdump -i external_api  -vvv   |grep fc51:158:46:17::32


tmpfs2
临时文件系统,驻留在内存中,比如常见的 /run
// 多分区只读,message无法vim,则可以拷贝至内存中,再查看message
cp message /run


top2 
动态检测进程运行状态      帮助:直接敲top,按h,实际帮助不大
// 按1  查看所有cpu占用详情
   按E  切换K M G T // 注意 Mem前有单位变化,单位过小会导致某值末尾+现象(仅仅是数字太大又展示不全,所以展示加号)    XXX+ total,     XXX+ free,     XXX+ buff 
   按f  自定义top展示字段    
   按M  内存使用率排序,效果: 按RES列(进程使用物理内存==resident内存 kB)降序
   按P  根据cpu排序 
top -M


tune2fs2 
// 我常用来查看fs status:clean还是clean with errors,所以此clean与fsck提示中still have error并不冲突
   clean	文件系统已正常卸载（无未修复的错误）。	正常关机或手动 umount 后。
   dirty	文件系统未正常卸载（可能存在未同步的元数据或错误）。	强制重启、崩溃、断电等异常情况。
   errors	文件系统已标记为存在错误（需手动修复）。	检测到不一致时（如 fsck 未完成修复）
tune2fs -l /dev/mapper/rootfs


ulimit2
ulimit -a // 强烈推荐这个
 open files // 进程打开的文件数量限制
ulimit // 直接查看core文件大小,返回unlimited代表core文件大小无限制
ulimit -c 1 // 设置core文件大小,单位blocks,block==1024字节
ulimit -c unlimited // 设置core文件大小无限制
强关联内容core_pattern
cat /proc/sys/kernel/core_pattern
/var/log/idump/core_%e_%p_%t // 代表默认生成的core文件在此目录下,且格式是"下面讲解"https://man7.org/linux/man-pages/man5/core.5.html
%e  The process or thread's comm value, which typically is the same as the executable filename 
%p  core掉的pid
%t  core掉的time


umount2 
// -l detach the filesystem now, and cleanup all later
   系统会立即断开挂载点的目录树，但实际的文件系统卸载会延迟到所有相关进程结束访问后再完成。这允许你卸载一个“繁忙”的文件系统，而无需先终止所有占用它的进程。
   典型使用场景：
      强制卸载被占用的挂载点：
      例如，当你无法直接卸载 NFS 共享或外接硬盘（因为有进程卡死或无法终止），可以用 umount -l 先解除挂载点，后续由系统自动处理残留的访问。
      避免阻塞操作：
      某些情况下（如网络存储不可达），常规卸载可能卡住，-l 可以立即返回，让卸载在后台完成
   -f --force
umount -l /var/log


uname2 
uname -a // unixName 通常带-a 显示系统信息(内核版本啥的)
uname -r // 直接查看内核版本


uptime2 
// 18:29:58->当前系统时间, 23:12->已经跑了7天23小时12分钟，当前只有1个用户登录，系统在最近1分钟、5分钟、15分钟内的平均负载分别为0.00、0.01、0.05
18:29:58 up 7 days, 23:12,  1 user,  load average: 0.00, 0.01, 0.05
// -s, --since    system up since
uptime -s


useradd2
// -m 创建用户家目录
   -s 指定新用户登录时所用shell /bin/false表示禁用用户登录系统
   -M 不创建用户homeDir
useradd -m XXX -s /bin/false 
   passwd XXX
   vim /etc/ssh/sshd_config // AllowUsers行尾添加XXX
   systemctl restart sshd


userdel2
// -r 删除用户家目录和mail spool(卷轴,卷盘)
userdel -r XXX


usermod2 
// 把hyj用户的家目录(默认/home/hyj)move到/home/hyj2目录下   实测细节:新的目录不能存在,存在会报错提示,用户的老家目录会删除,一创一删给人感觉就是老家目录换了个目录名字
usermod -md /home/hyj2 hyj


/var/log/secure
密码的改动会被记录,如 password changed for XXX


// 常常通过ssh从首节点跳转到其他节点,其他节点过一会会自动退出,但自己又不是守在屏幕前,所以不清楚是目前首节点还是其他节点
who


xargs 
// 给命令传递参数,怎么传递的就很迷
// 常常用来umount前杀进程
lsof -t /var/log |xargs kill -9 
// 多行输出
lsof -t /var/log |xargs cat
// 一行输出
lsof -t /var/log |xargs ll
// 多行输出
lsof -t /var/log |xargs ls -s 


yum2 
// 配置仓库/etc/yum.repo.d/??.repo
yum search git
yum install git
yum list installed |grep git*
yum remove git
yum provides ld // 由此编东西提示ld缺失,以为是binutils包里面的,实际是binutils-extra包里面的(provides含金量来了!!!)
// 通常添加或者删除XXX.repo后,需要一下两步骤
yum clean all // 删除yum缓存中可用包和旧缓存,yum clean删除前者
yum makecache // 生成缓存
// 从本机的yum源中下载httpd软件包
yumdownloader httpd


grep2 
grep "ip_local_reserved_ports" -nr /usr/lib		// -n 显示num  -r 递归目录
lsof -i:49208  // 山哥说只要有输出,本机在用此端口,   770是指对端ip
netstat -tunlp 49208
sysctl -a | grep ip_local_reserved_ports // -a 显示所有的系统参数
ip a  // Linux系统中用于查看IP地址信息的命令


timeout2 
// Usage: timeout [OPTION] DURATION COMMAND [ARG]...
// -s 发送signal 如果600s内reboot命令没执行完,则发送 KILL 信号,终止reboot命令
timeout -s KILL 600 reboot 
// ping会一直ping的,下面这个就很好理解,让它ping 2秒后就kill掉
timeout -s KILL 2 ping www.baidu.com


watch2 
监视命令
// -d 高亮变化差异
   -n2 采样间隔2sec
watch -d -n2 'ps -ef |grep systemd |grep -v grep'


wc2 
// -l line counts统计行
wc -l XXX.txt
XXX |wc -l


zgrep2 
// -a  --text equivalent to --binary-files=text      treat all files as text
zgrep -an "TLS handshake" ./logdump*


& 表示任务后台执行，与nohup命令功能差不多。   通常放在命令的末尾
&& 表示前一条命令执行成功时，才执行后一条命令。
|| 表示上一条命令执行失败后，才执行下一条命令。
